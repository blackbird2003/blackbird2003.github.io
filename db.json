{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","path":"js/sidebar.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/2024-05-21-diary/index.md","hash":"62aa0868e90f053a9c4d31b601fa79188970cfe1","modified":1756188801743},{"_id":"source/_posts/GAMES101-作业7-路径追踪-踩坑指南.md","hash":"8518164823b496d67be5f0a0a369b68604cd4d35","modified":1756188801743},{"_id":"source/_posts/GAMES101-作业8-质点弹簧系统-踩坑指南.md","hash":"190141ce8279bcb6d1cea087afc63bc984b13fa4","modified":1756188801745},{"_id":"source/_posts/TinyRendererNotes.md","hash":"43dd7c2df4224f8f0d73f30de0c15568a9e17d2f","modified":1756188801746},{"_id":"source/_posts/hello-world-nya.md","hash":"788d0259e15c11744ecba2e7f2c4cdacc4f4d089","modified":1756188801746},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1756188801746},{"_id":"source/_posts/test.md","hash":"e6f0b1e4ea1a7271b09eb55d8c178ee0bbb8acf3","modified":1756188801750},{"_id":"source/about/index.md","hash":"2c501e6637efcda14c8b9800ace459af17de7712","modified":1756192566243},{"_id":"source/_posts/image-20240416132845514.png","hash":"5c616708addd3b0cf9774c9e4e591fa854a7f521","modified":1756188801748},{"_id":"source/_posts/GAMES101-作业7-路径追踪-踩坑指南/image-20240416133742442.png","hash":"5c616708addd3b0cf9774c9e4e591fa854a7f521","modified":1756188801745},{"_id":"source/_posts/image/GAMES101-作业7-踩坑指南/1713230279835.png","hash":"c780eda4b8804cafbc98301af60688a769b54801","modified":1756188801750},{"_id":"source/_posts/image-20240416132834246.png","hash":"4b92de650a815550855ca9c48fedc988e1510f9f","modified":1756188801747},{"_id":"source/_posts/GAMES101-作业7-路径追踪-踩坑指南/image-20240416133728725.png","hash":"4b92de650a815550855ca9c48fedc988e1510f9f","modified":1756188801744},{"_id":"source/_posts/image/GAMES101-作业7-踩坑指南/1713229011326.png","hash":"83ac1ddecce632c7735b5fc154d191a0b6d90e26","modified":1756188801749},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1756190140393},{"_id":"node_modules/hexo-theme-next/README.md","hash":"6f1bf93dbccc8545872fe27b4693fda59cdbfb89","modified":1756190140397},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"94ae5888e628f7f67f776e4296cf8dae8bc25fd5","modified":1756190140555},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"5c6d3f23d65b77717d1b3e7b5575104f7d41b056","modified":1756190140556},{"_id":"node_modules/hexo-theme-next/package.json","hash":"81c9f00b10b811c0485c00a2d7810e525f0b0e93","modified":1756190140387},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1756190140390},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":1756190140390},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1756190140554},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1756190140395},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"7d0f39e8684284a04bb9808521c87fecda8bd131","modified":1756190140556},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"564bed75da6e05b11dce6164508f97a15e2fb6c2","modified":1756190140557},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"79b37df731c29665dee6cd7c90d278e1edfb6e24","modified":1756190140557},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"ba0fd79a2b1d8db01a034180556061745965ff05","modified":1756190140558},{"_id":"node_modules/hexo-theme-next/languages/eo.yml","hash":"e34bb33ae827bf2f0727088599a73bc64bdad1b0","modified":1756190140558},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"dffc63ef42e1266b88e0acf08994fd17a9908d53","modified":1756190140559},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"f3ffc444599f4ac92d62e9ed00a1490ebc277d70","modified":1756190140560},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"8ac44e58f71a38b7697a2f7f98a6971ed818cb5b","modified":1756190140560},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"929df147f4f17d638b07de5fe52ca13e2549ab1c","modified":1756190140560},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"16d716ecfd748def2f6486ef5a82d0ab7ceb4890","modified":1756190140561},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"543222bfc516aab6c33e8534f807972ecb8943a9","modified":1756190140561},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"d345a303310c8a5f4836c3683f3580f861ebd1b4","modified":1756190140562},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"3cb3687696635ec71b4ca40c5fc43b56acc8843e","modified":1756190140562},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"76b8576ce228d540a16b1f0af5af2cce20923194","modified":1756190140563},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"b62faaa767a45a613dd042b5f1903675eb5a8cf9","modified":1756190140563},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"c6d8de0ff7d8148d09993257cfd3b7aca755696c","modified":1756190140564},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"2d712eedf3f60d04d36c3108cf5a12e2a52e875c","modified":1756190140565},{"_id":"node_modules/hexo-theme-next/languages/th.yml","hash":"6829e998b39f8f143e20b276bb1f62d95a29de58","modified":1756190140565},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"511726054873f6f8d7ce0d2e803f6731de0ddbe7","modified":1756190140566},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"a57e4ed089b893a95f5e1ecff17ce625165f4d46","modified":1756190140566},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"ff537047b4b4c3ca9a7b64fa7f428a9942751eeb","modified":1756190140567},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"7ebcba5e1128784195e4681dffc9d34c4e873fec","modified":1756190140568},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"741d7efe0262c9cdc2c648014b55599665d90f6b","modified":1756190140568},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"8eb6a9f231ce1bfa54cc54418ccf14f01dcc9a31","modified":1756190140569},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"5c0f00cdac3f4727b880dd223f622a535736fa8e","modified":1756190140570},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"b17d44bd7379c23241053a0b7fbd38c9c43cc239","modified":1756190140399},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1756190140400},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":1756190140428},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":1756190140451},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"af6d7570621be760536c216a56d74e40a1cceae2","modified":1756190140464},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"0bfce9f133f501a9a4837257e3b862b3bbca15be","modified":1756190140470},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":1756190140475},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"30e929e1138445534a6f46d64667c17273337acf","modified":1756190140394},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"12a6631617695504d5cf2a94b57d87bd331bef6f","modified":1756190140391},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":1756190140392},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"93064dbd1a461d55c7c07a04626294c8150b4d1b","modified":1756190140395},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"ec9bb9c5ede773c02f0c8d8475245a8a437a2b71","modified":1756190140470},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"313637fe3569f98fd926e8cd0fcc75d098eb6e6e","modified":1756190140466},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"85f3a2ab22601a9606f2f630289db1363b98018f","modified":1756190140472},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":1756190140430},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"fbf8232cacf0df87e88e74860be66c9f86018302","modified":1756190140432},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1756190140452},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"bc719473ed5948ab6859449d60b8d36cfc1542b4","modified":1756190140464},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"d83fb59f02c5e6630a7770401a05c02f6f07358b","modified":1756190140478},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"2a7dfffebad19b67dc9e3b2a6b2986d0630ef930","modified":1756190140442},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"7261e24287984853c8ef08cda8bbc80cacf9bd6f","modified":1756190140477},{"_id":"node_modules/hexo-theme-next/layout/_third-party/addtoany.njk","hash":"ef64c6bfb8540cd874701236b9be47db2496e98e","modified":1756190140399},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":1756190140431},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"dfd7cdd6ba89f8c3deabc27726c7a350cadafd11","modified":1756190140448},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":1756190140460},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":1756190140471},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"bd9ea82376cd87df611ea3ae077875c7c595a3df","modified":1756190140358},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1756190140348},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":1756190140365},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"2063aaa1db448ebcf7b0fdbbc54d3991a368bbd3","modified":1756190140371},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"fdc8a0af90035e89c3fcb754a0eb189b8951a2bc","modified":1756190140379},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"83235f2879567eb8686431c9554a4b99f14ab665","modified":1756190140351},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"4c84d45daac86396edf656d2a8abe6e7583491ea","modified":1756190140354},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":1756190140373},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"4bc2eb87f3fa26981652f517d1ab3f81de2ab89d","modified":1756190140374},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-paginator.js","hash":"e86c764b546e4fbb87970cabc4135a56f9ef9fe1","modified":1756190140374},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"6281d47c1de98eb38f3aa0f6df29bbb19d412173","modified":1756190140375},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"af3946a595f997eb43d9af87428e4898c9acbc82","modified":1756190140375},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1756190140340},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1756190140340},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1756190140341},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"1f6aba7820f1fb58b61969485148db21846e1aa9","modified":1756190140358},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"f57f7e09eb6220f681fa8385082b0960502ce5c4","modified":1756190140356},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1756190140361},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1756190140362},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"7d7bbc4a9970bd4c5449bc71b94364a8ec61e5d2","modified":1756190140370},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1756190140376},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1756190140377},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1756190140381},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1756190140385},{"_id":"node_modules/hexo-theme-next/scripts/tags/wavedrom.js","hash":"b44dfeeb58b41945d469141787f3dbce4b117d08","modified":1756190140386},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"ebfe0954e3931431f46f913abe08d0212e06e7c2","modified":1756190140480},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"e21309d4165ebb6645084eed8dd749846ae981f1","modified":1756190140491},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"921a58577f411cf4eb5cfd66db0a241f8f88578c","modified":1756190140530},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"dadc81256afb127b77eac6763d5ee0ec9c77f0a3","modified":1756190140536},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1756190140478},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1756190140298},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1756190140479},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1756190140479},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"a38c6d92b368bfc42c72ad799ad03f3274957065","modified":1756190140552},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1756190140554},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"9ba4cceafd12c6d5ba8a6b986a046ef8319a7811","modified":1756190140338},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1756190140344},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1756190140345},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1756190140347},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"6f751f5c9499a39d7c5e1d323db3260342dd9431","modified":1756190140371},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"d434a2a8543fb09245eaf2bc6ca123435bfa4dbb","modified":1756190140374},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"694b271819aab37ce473b15db9e6aded971d82e5","modified":1756190140378},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"9c41a73ed3e8db8ca4cb53633b6f616279a5a7bd","modified":1756190140381},{"_id":"node_modules/hexo-theme-next/source/js/sidebar.js","hash":"2ee359ae48273b01ba1e0768704524e08702c7eb","modified":1756190140381},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"6734719bb74e4d9818992b0e4a745c2a1aefd5e2","modified":1756190140384},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"93c1d103d9d16581c944c51f3d0638f57c80ee41","modified":1756190140434},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"5388b157bba4a40b9312f4a45c6678974ccf0837","modified":1756190140436},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"dd9c4c03e99dfde0dfb8edefcb2c933f2f560efc","modified":1756190140403},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":1756190140457},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":1756190140440},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":1756190140458},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":1756190140473},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":1756190140417},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1756190140426},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1756190140463},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":1756190140471},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1756190140475},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"bfff923526d6800218f08dba6ce0bbf5c17755fd","modified":1756190140467},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"c1e33b4889f75acc490af3c8bde0ec56c518ff41","modified":1756190140467},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":1756190140468},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"e0986db00a0201dd3c60570f964829c84ba5bc68","modified":1756190140468},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"e8b8a7c41e9ec612d0c0c73419529d55d1c16256","modified":1756190140468},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-share.njk","hash":"16696990e4ce65fc8db18c4635082a5d5d06ff07","modified":1756190140469},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"6ad43135bd3aecf933ffdd750763e27ade36f97c","modified":1756190140441},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"bc5708e38b6070dff0cab6bf9480971017ce4dda","modified":1756190140473},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1756190140400},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":1756190140430},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1756190140433},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1756190140433},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"f900306497b133e8b098bd9f4b96b93d1d96c185","modified":1756190140445},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":1756190140455},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"1efeeda00db08a3c033798228dd0092ee532cc36","modified":1756190140458},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/plausible.njk","hash":"ef9f2bb7110507f1c4336800af9157d5fa9765bd","modified":1756190140465},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/umami.njk","hash":"3343750682fbd8535e50f8129be3003ad26015b4","modified":1756190140476},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":1756190140429},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":1756190140476},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1756190140429},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1756190140430},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":1756190140431},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":1756190140432},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1756190140451},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1756190140453},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1756190140476},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1756190140449},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":1756190140451},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1756190140454},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"41b28f05e6233fb37700f7151f55868be10a0965","modified":1756190140400},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":1756190140453},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"55c2468b2b7f035881d494085527d6554f37b556","modified":1756190140426},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":1756190140432},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1756190140450},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1756190140452},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1756190140458},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1756190140465},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/wavedrom.njk","hash":"02202bf563fb5eedde2ccad4d6c5b9109d30a703","modified":1756190140477},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"00af4f5f9a79eaccf051f9e372d233d65d44c8a5","modified":1756190140346},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"8a8f752260be5b8098393f9879b61ffe904465e8","modified":1756190140357},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":1756190140359},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":1756190140373},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"5942feb3f31ed3480bf50b0f5a4a305b5bdca3d6","modified":1756190140382},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"e2b4a9d6b08155735ec336eedc506763d5671821","modified":1756190140385},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":1756190140341},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":1756190140345},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1756190140347},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":1756190140349},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"a600a98e7436edeb31e291abca359885567df3c9","modified":1756190140350},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":1756190140354},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1756190140360},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":1756190140362},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1756190140384},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1756190140505},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"2c800eaab6c613e5d091be2111aaa786641aa0c2","modified":1756190140533},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"879b49f693af0c04c285b2dd0c9cccaf77347b7c","modified":1756190140534},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"b724edca546373d5eaf9b3602868f971c9094cf6","modified":1756190140496},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"20d5c6aa136bbb55e03906d98ee90ad3fbaa80a7","modified":1756190140537},{"_id":"node_modules/hexo-theme-next/source/js/third-party/addtoany.js","hash":"a772605646dcfb67620a10ee8ef23c38a6d19d80","modified":1756190140316},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1756190140352},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1756190140376},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1756190140380},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"b8445c828d78a38e2de50bdc86b3bff66285ea0f","modified":1756190140493},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"2298e521253b3bf376a2412271bc2a7d305051f3","modified":1756190140508},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":1756190140543},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":1756190140513},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"48b2dfc04df6409c6e0736ccc11462ad97d349b1","modified":1756190140534},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"f316ba87f8d3299677fbf8345e1e993c35210e2e","modified":1756190140494},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1756190140500},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1756190140501},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1756190140520},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1756190140534},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"f4228c759db4a650c8d38745c2edd1dc83c45687","modified":1756190140537},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1756190140550},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"69c66aab4651e2e7ae9e65f08600144970648c60","modified":1756190140551},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"bcbf498d8d3ecea84324f0a59b7f95f389a52b8d","modified":1756190140527},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"3fbfab591f280e2e7f3b0265901c93bc4bd137ed","modified":1756190140485},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"6569a6640f79d247a8235b3914772c0e2f99ead2","modified":1756190140487},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"e31f6adbb22a451f07e4661cff9a2f12e4e99a36","modified":1756190140489},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"c29a827e82d2820ed8977c92994da73721200fac","modified":1756190140491},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1756190140492},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1756190140529},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"dafc6d23c80d6fe3e55a7711e94210d2479b629a","modified":1756190140481},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"fa4fd8f76464e214fb7318f325b13c2b62f4b478","modified":1756190140487},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"f23c53e32d140091b819be2603d1afbbb5d66933","modified":1756190140489},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"485d23ccb42c0d0c8ead7ea8930dd3e06d79a285","modified":1756190140491},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1756190140529},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"dc03835e42d82eaf2633cf3b627990ad3e1f5967","modified":1756190140486},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"a92c4eb16bdb7806079467eb022ccf193bb0f794","modified":1756190140488},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"a03f16ffc7dfdbdc6053f9fd68d77257ba0c559e","modified":1756190140489},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e792a6233e1d4dbc5fd2f10ae97b7a790b82568b","modified":1756190140492},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1756190140492},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1756190140529},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1756190140336},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1756190140355},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1756190140356},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1756190140369},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1756190140344},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1756190140381},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"6c65d5a585b7dd75e5f0fa6ef2dc85d0bcd1e58f","modified":1756190140343},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"3631db0315bdeaa420091a9febb6fa3421a2bdb4","modified":1756190140349},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"e01b42846ffcabc676c3bdd9d89e8cafc084e20b","modified":1756190140350},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"03eb13679fc701c2ab91e502ccd26aacc37e7999","modified":1756190140354},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"917d1a2bbae6cc8817ce37abc17800b1740b2517","modified":1756190140360},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"e35e5a90a70a96117509368423726c6a56041ea2","modified":1756190140364},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"743f389fc5669e486c8804d7199a11542ff9bc11","modified":1756190140384},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1756190140361},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1756190140366},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"6b3fa841e48d8637a33530dd48c8ab1ef317323c","modified":1756190140336},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"3968d972f47b79acc6c3fe44028bad77c9c5aab7","modified":1756190140364},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"fec1c5c913237112b2cc6fb7d1e73b789bf508f8","modified":1756190140353},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"171889aaab60704f87cfe9a05871f493ac292b47","modified":1756190140361},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"ae1c0c6c079594936de1aea756eb58992f8fb0e0","modified":1756190140370},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"7e6ad201d2c9d682261209db5dba07e9608fb42a","modified":1756190140377},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/wavedrom.js","hash":"71efb52a4c44c64c2b17edd4638d54ec884bd4c7","modified":1756190140386},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1756190140499},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"51a97a33879289904cb523ddc2d88b5b0c60fa72","modified":1756190140500},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1756190140509},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1756190140544},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1756190140550},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"098d4bd034e986fcf7e443eac4fc2193935461b7","modified":1756190140510},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"93f014809d6442da23f8b7d729f7375e2badba7d","modified":1756190140538},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"809bab3414b1eb1ae44444eb821126868f764414","modified":1756190140539},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"026cd5735fd2a75bb60b7bf8bd09139583d602b9","modified":1756190140539},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"bb089299f87793bd5eff80c6375d4e796367b67b","modified":1756190140540},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1756190140540},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"424de4f64b12c521e8c6bfbc711d7961490ab36e","modified":1756190140541},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1756190140541},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"b47fb36915962309553ff7fb1782341585ed2b76","modified":1756190140541},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"ebfba158a0a4af3d1dabcacbc58986664de52140","modified":1756190140543},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"877a537d5b95beb048142e4fdee6f17e6ef9c7bb","modified":1756190140503},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"8f094c4ac17e2ab45569b12d157747f9c7333c12","modified":1756190140505},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"54d12e2c5d9982f7b9e5b23be5133954a8514e9d","modified":1756190140510},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":1756190140530},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"1874e2b5d86cdeeaf2ccdc2669146a2b0c72d9db","modified":1756190140544},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":1756190140551},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"4e967702cf4c637132346bc74ec8854426f1a68c","modified":1756190140512},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":1756190140498},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":1756190140506},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"6e0d0796ef7fbbb62ffdfb448753a850de82c74f","modified":1756190140512},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"a3dd3edea9c01b66b28a8367185269b9dcc3bdee","modified":1756190140532},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"a851e9d5aefcd027c95eeb323860b6da70f202d1","modified":1756190140549},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"21acb11e397526132605eef23bde7b307aa1eab5","modified":1756190140515},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b05908f04ef95f2d91e6eba89b12411c378d050f","modified":1756190140543},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1756190140549},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"0847400d8579b0a2dd1bf662c78954c10adf2680","modified":1756190140545},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1756190140545},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"ce36bf1602233298e0351b4babc592315529eb26","modified":1756190140545},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"46eece42510c2c89bb9209afb0262ad76a4b0b36","modified":1756190140546},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"24752d145c6fb8f5344dca9c7b9640839c02e009","modified":1756190140547},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-copyright.styl","hash":"56805b77fe236fac19e19c716a49363bcf986311","modified":1756190140546},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"c2e354a565c8c1b32bd0ceacc972b17982758b67","modified":1756190140548},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"741566d6ac5f852b5c8dee6a8996b65e48e7c97f","modified":1756190140548},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"5c31f3a86e4e6fbf2f8419415620461fa8a63c56","modified":1756190140501},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":1756190140550},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/fold.styl","hash":"42a0b65491ad85438596b3fe0b7f23973e4cef34","modified":1756190140504},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"9b0217e1caecd91e05572c7e8e52d32016ca312f","modified":1756190140515},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":1756190140496},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1756190140508},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"22cd37bd5df9972d5074710896aba4424ad5161c","modified":1756190140521},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1756190140530},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"49329a7144f3413d1c832e52a1f4954171ef11e1","modified":1756190140530},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":1756190140532},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"8213015d9cae45d2c9945f8aba9d8db39c734efc","modified":1756190140536},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":1756190140537},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"c3be8b0738f693e750486bb71769c3dbbec174cc","modified":1756190140550},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"af113411ad9cca7674177be36af8dd399680834d","modified":1756190140551},{"_id":"public/2024-05-21-diary/index.html","hash":"e5b2097bbc3d5ef876074622b2fdb8e83bc34990","modified":1756194222686},{"_id":"public/about/index.html","hash":"294e1283d4bbeed375b5855095c710b70412e3be","modified":1756194222686},{"_id":"public/2025/08/26/hello-world/index.html","hash":"e8edc9b0c959cf6aa8ff9aa15c487abad9bb8da2","modified":1756194222686},{"_id":"public/2025/07/14/test/index.html","hash":"ea806c07636bdcb03479c9e7c3b091060fc7f6d7","modified":1756194222686},{"_id":"public/2024/05/28/GAMES101-作业8-质点弹簧系统-踩坑指南/index.html","hash":"cba86c2c5c4dfc1360d363fc8e19f3e90e10e8bf","modified":1756194222686},{"_id":"public/2024/05/06/TinyRendererNotes/index.html","hash":"7dedb4781c64799d836c6d912247ef641e1a0880","modified":1756194222686},{"_id":"public/2024/04/16/GAMES101-作业7-路径追踪-踩坑指南/index.html","hash":"32c0e3969c70ec19eb7b67c795a82cde5b01910e","modified":1756194222686},{"_id":"public/2024/04/14/hello-world-nya/index.html","hash":"59f07242fdb8ec0e15eb3a32e6bcfeed0033aeb6","modified":1756194222686},{"_id":"public/archives/index.html","hash":"850ad8e23f55dd59a22a21a7801102b12d3fef1a","modified":1756194222686},{"_id":"public/archives/2024/index.html","hash":"deae091b7db2e7d123d7bbd08eb2cc64b1a60486","modified":1756194222686},{"_id":"public/archives/2024/04/index.html","hash":"4da40a977985a737a300b411d157aba54917420f","modified":1756194222686},{"_id":"public/archives/2024/05/index.html","hash":"d0c4809526b649f91d84966d036095b6ef6fd5f5","modified":1756194222686},{"_id":"public/archives/2025/index.html","hash":"44cbb0734a05e1d0ae9050ba0f5b9fc4404f7db0","modified":1756194222686},{"_id":"public/archives/2025/07/index.html","hash":"7d4d3a6f8d1f5b920d668dfcd5619f6fd10482ac","modified":1756194222686},{"_id":"public/archives/2025/08/index.html","hash":"ad1c4744eba24dc544ed832b34b36a87213dcd40","modified":1756194222686},{"_id":"public/index.html","hash":"d01f0f3cc73c92faefeab48666f65be519d50610","modified":1756194222686},{"_id":"public/tags/图形学/index.html","hash":"990607d4aa566487d1b73eb956cb0d5978182701","modified":1756194222686},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1756194222686},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1756194222686},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"a38c6d92b368bfc42c72ad799ad03f3274957065","modified":1756194222686},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1756194222686},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1756194222686},{"_id":"public/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1756194222686},{"_id":"public/css/main.css","hash":"46413d4ffac926c668f865071f81515e87b1130c","modified":1756194222686},{"_id":"public/css/noscript.css","hash":"4cd5301e478e0e0d4b176740ec314087ec5cb707","modified":1756194222686},{"_id":"public/js/bookmark.js","hash":"9ba4cceafd12c6d5ba8a6b986a046ef8319a7811","modified":1756194222686},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1756194222686},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1756194222686},{"_id":"public/js/motion.js","hash":"6f751f5c9499a39d7c5e1d323db3260342dd9431","modified":1756194222686},{"_id":"public/js/next-boot.js","hash":"d434a2a8543fb09245eaf2bc6ca123435bfa4dbb","modified":1756194222686},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1756194222686},{"_id":"public/js/pjax.js","hash":"694b271819aab37ce473b15db9e6aded971d82e5","modified":1756194222686},{"_id":"public/js/schedule.js","hash":"9c41a73ed3e8db8ca4cb53633b6f616279a5a7bd","modified":1756194222686},{"_id":"public/js/sidebar.js","hash":"2ee359ae48273b01ba1e0768704524e08702c7eb","modified":1756194222686},{"_id":"public/js/third-party/addtoany.js","hash":"a772605646dcfb67620a10ee8ef23c38a6d19d80","modified":1756194222686},{"_id":"public/js/utils.js","hash":"6734719bb74e4d9818992b0e4a745c2a1aefd5e2","modified":1756194222686},{"_id":"public/js/third-party/fancybox.js","hash":"819f382c561fe5ec23c67cc5fabd63dd1cc22dc1","modified":1756194222686},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1756194222686},{"_id":"public/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":1756194222686},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"def07bcc7c17d8a0caad177fb1dd2f3a5e5b3536","modified":1756194222686},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1756194222686},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1756194222686},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1756194222686},{"_id":"public/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":1756194222686},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1756194222686},{"_id":"public/js/third-party/comments/changyan.js","hash":"6c65d5a585b7dd75e5f0fa6ef2dc85d0bcd1e58f","modified":1756194222686},{"_id":"public/js/third-party/comments/disqus.js","hash":"3631db0315bdeaa420091a9febb6fa3421a2bdb4","modified":1756194222686},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"e01b42846ffcabc676c3bdd9d89e8cafc084e20b","modified":1756194222686},{"_id":"public/js/third-party/comments/gitalk.js","hash":"03eb13679fc701c2ab91e502ccd26aacc37e7999","modified":1756194222686},{"_id":"public/js/third-party/comments/isso.js","hash":"917d1a2bbae6cc8817ce37abc17800b1740b2517","modified":1756194222686},{"_id":"public/js/third-party/comments/utterances.js","hash":"743f389fc5669e486c8804d7199a11542ff9bc11","modified":1756194222686},{"_id":"public/js/third-party/comments/livere.js","hash":"e35e5a90a70a96117509368423726c6a56041ea2","modified":1756194222686},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1756194222686},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1756194222686},{"_id":"public/js/third-party/search/local-search.js","hash":"3968d972f47b79acc6c3fe44028bad77c9c5aab7","modified":1756194222686},{"_id":"public/js/third-party/statistics/firestore.js","hash":"fec1c5c913237112b2cc6fb7d1e73b789bf508f8","modified":1756194222686},{"_id":"public/js/third-party/search/algolia-search.js","hash":"6b3fa841e48d8637a33530dd48c8ab1ef317323c","modified":1756194222686},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"171889aaab60704f87cfe9a05871f493ac292b47","modified":1756194222686},{"_id":"public/js/third-party/tags/mermaid.js","hash":"ae1c0c6c079594936de1aea756eb58992f8fb0e0","modified":1756194222686},{"_id":"public/js/third-party/tags/pdf.js","hash":"7e6ad201d2c9d682261209db5dba07e9608fb42a","modified":1756194222686},{"_id":"public/js/third-party/tags/wavedrom.js","hash":"71efb52a4c44c64c2b17edd4638d54ec884bd4c7","modified":1756194222686},{"_id":"public/2024/04/16/GAMES101-作业7-路径追踪-踩坑指南/image-20240416133742442.png","hash":"5c616708addd3b0cf9774c9e4e591fa854a7f521","modified":1756194222686},{"_id":"public/2024/04/16/GAMES101-作业7-路径追踪-踩坑指南/image-20240416133728725.png","hash":"4b92de650a815550855ca9c48fedc988e1510f9f","modified":1756194222686}],"Category":[],"Data":[],"Page":[{"title":"2024/05/21 diary","date":"2024-05-21T02:16:30.000Z","type":"diary","_content":"","source":"2024-05-21-diary/index.md","raw":"---\ntitle: 2024/05/21 diary\ndate: 2024-05-21 10:16:30\ntype: diary\n---\n","updated":"2025-08-26T06:13:21.743Z","path":"2024-05-21-diary/index.html","comments":1,"layout":"page","_id":"cmes8p3640000lkw975lcgu8g","content":"","excerpt":"","more":""},{"title":"about","date":"2024-04-14T07:58:57.000Z","_content":"\n你好，这里是blackbird/_vv123/Wei Xianghan.\n\n旧Blog: cnblogs.com/vv123 主要是ACMer时期的内容\n\nQQ:2593251154 / 2084654100(动态专用)\n\n小红书: blackbird \n\nBilibili: _blackbird\n\n网抑云音乐：__blackbird\n\n待过的地方: 微山，邹城二实小/六中/一中，电子科技大学(成都)，電気通信大学(東京都調布市)，浙江大学(杭州&宁波)\n\n喜欢的东西：Galgame, RPG游戏，铁道，各种各样的音乐(see __blackbird)。还是雏草姬()\n\n友链：atri2333.github.io\n\n\n<!-- Wei Xianghan です。UESTC Computer Science 三年生です。電気通信大学(UEC)に交換留学中です。\n\n之前是ACMer，最好的成绩2023区域赛（杭州）银牌。现在在学图形学。\n\ncodeforces：_vv123 atcoder:AceBlackbird\n\n之前的博客 cnblogs.com/vv123\n\n喜欢的游戏：Finding Paradise, OMORI, Terraria, etc\n\n网抑云音乐：__blackbird\n\n友链：atri2333.github.io -->\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-04-14 15:58:57\n---\n\n你好，这里是blackbird/_vv123/Wei Xianghan.\n\n旧Blog: cnblogs.com/vv123 主要是ACMer时期的内容\n\nQQ:2593251154 / 2084654100(动态专用)\n\n小红书: blackbird \n\nBilibili: _blackbird\n\n网抑云音乐：__blackbird\n\n待过的地方: 微山，邹城二实小/六中/一中，电子科技大学(成都)，電気通信大学(東京都調布市)，浙江大学(杭州&宁波)\n\n喜欢的东西：Galgame, RPG游戏，铁道，各种各样的音乐(see __blackbird)。还是雏草姬()\n\n友链：atri2333.github.io\n\n\n<!-- Wei Xianghan です。UESTC Computer Science 三年生です。電気通信大学(UEC)に交換留学中です。\n\n之前是ACMer，最好的成绩2023区域赛（杭州）银牌。现在在学图形学。\n\ncodeforces：_vv123 atcoder:AceBlackbird\n\n之前的博客 cnblogs.com/vv123\n\n喜欢的游戏：Finding Paradise, OMORI, Terraria, etc\n\n网抑云音乐：__blackbird\n\n友链：atri2333.github.io -->\n","updated":"2025-08-26T07:16:06.243Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmes8p3690002lkw9d1lka3qt","content":"<p>你好，这里是blackbird&#x2F;_vv123&#x2F;Wei Xianghan.</p>\n<p>旧Blog: cnblogs.com&#x2F;vv123 主要是ACMer时期的内容</p>\n<p>QQ:2593251154 &#x2F; 2084654100(动态专用)</p>\n<p>小红书: blackbird </p>\n<p>Bilibili: _blackbird</p>\n<p>网抑云音乐：__blackbird</p>\n<p>待过的地方: 微山，邹城二实小&#x2F;六中&#x2F;一中，电子科技大学(成都)，電気通信大学(東京都調布市)，浙江大学(杭州&amp;宁波)</p>\n<p>喜欢的东西：Galgame, RPG游戏，铁道，各种各样的音乐(see __blackbird)。还是雏草姬()</p>\n<p>友链：atri2333.github.io</p>\n<!-- Wei Xianghan です。UESTC Computer Science 三年生です。電気通信大学(UEC)に交換留学中です。\n\n之前是ACMer，最好的成绩2023区域赛（杭州）银牌。现在在学图形学。\n\ncodeforces：_vv123 atcoder:AceBlackbird\n\n之前的博客 cnblogs.com/vv123\n\n喜欢的游戏：Finding Paradise, OMORI, Terraria, etc\n\n网抑云音乐：__blackbird\n\n友链：atri2333.github.io -->\n","excerpt":"","more":"<p>你好，这里是blackbird&#x2F;_vv123&#x2F;Wei Xianghan.</p>\n<p>旧Blog: cnblogs.com&#x2F;vv123 主要是ACMer时期的内容</p>\n<p>QQ:2593251154 &#x2F; 2084654100(动态专用)</p>\n<p>小红书: blackbird </p>\n<p>Bilibili: _blackbird</p>\n<p>网抑云音乐：__blackbird</p>\n<p>待过的地方: 微山，邹城二实小&#x2F;六中&#x2F;一中，电子科技大学(成都)，電気通信大学(東京都調布市)，浙江大学(杭州&amp;宁波)</p>\n<p>喜欢的东西：Galgame, RPG游戏，铁道，各种各样的音乐(see __blackbird)。还是雏草姬()</p>\n<p>友链：atri2333.github.io</p>\n<!-- Wei Xianghan です。UESTC Computer Science 三年生です。電気通信大学(UEC)に交換留学中です。\n\n之前是ACMer，最好的成绩2023区域赛（杭州）银牌。现在在学图形学。\n\ncodeforces：_vv123 atcoder:AceBlackbird\n\n之前的博客 cnblogs.com/vv123\n\n喜欢的游戏：Finding Paradise, OMORI, Terraria, etc\n\n网抑云音乐：__blackbird\n\n友链：atri2333.github.io -->\n"}],"Post":[{"title":"GAMES101 作业7 路径追踪 踩坑指南","date":"2024-04-16T05:35:32.000Z","_content":"\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n首先回顾路径追踪的原理，如下图\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121322581-1913642501.png\" alt=\"1713229011326\" style=\"zoom:50%;\" />\n\n\n## 基本思想\n\nwo是射向眼镜（相机）的光线，包含来自光源的直接光照ws，来自其他物体的间接光照wi两部分。\n\n在实现path tracing时，我们考虑的是黄色线的方向，即光线从相机射向p点（实际上是从p点射向相机），然后通过多次随机采样从p点射出（实际上是射向p点）的光线得到该像素点的真实颜色。\n\n为了提高效率，将射向p的光线分为ws(光源)和wi（其他物体）计算。由于wi、ws分开计算，因此如果ws被物体挡住,或者wi打到光源均不计算。\n\nwi需要递归计算，通过神奇的Russian Roulette在减少递归层数的同时保持光照的期望不变。\n\n然后按照作业指南上的伪代码写就可以了\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121328730-1409855486.png\" alt=\"1713230279835\" style=\"zoom:80%;\" />\n\n\n\n## 注意事项\n\n- 右墙壁发黑：检查Bound3::IntersectP, `return t_enter <= t_exit && t_exit >= 0;` 就可以\n- 小正方体右上角有三角形黑块:检查Triangle::getIntersectionin Triangle.hpp，当时间小于0时不能判定为相交\n- 多线程：注意framebuffer的下标应该由m改为直接用i和j计算。CMakeLists.txt加一行 `TARGET_LINK_LIBRARIES(RayTracing pthread)`就好。\n\n## 代码\n\n### 多线程优化\n\n```cpp\n    // change the spp value to change sample ammount\n    int spp = 32; // default:16\n    std::cout << \"SPP: \" << spp << \"\\n\";\n\n    // for (uint32_t j = 0; j < scene.height; ++j) {\n    //     for (uint32_t i = 0; i < scene.width; ++i) {\n    //         // generate primary ray direction\n    //         float x = (2 * (i + 0.5) / (float)scene.width - 1) *\n    //                   imageAspectRatio * scale;\n    //         float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;\n\n    //         Vector3f dir = normalize(Vector3f(-x, y, 1));\n    //         for (int k = 0; k < spp; k++){\n    //             framebuffer[m] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  \n    //         }\n    //         m++;\n    //     }\n    //     UpdateProgress(j / (float)scene.height);\n    // }\n    // UpdateProgress(1.f);\n\n    const int thread_cnt = 12;\n    int finished_thread = 0;\n    int finished_width = 0;\n    std::mutex mtx;\n  \n    printf(\"%d %d\\n\", scene.height, scene.width);\n    auto multiThreadCastRay = [&](uint32_t y_min, uint32_t y_max) \n    {\n        printf(\"start %d %d\\n\", y_min, y_max);\n        for (uint32_t j = y_min; j <= y_max; ++j) {\n            for (uint32_t i = 0; i < scene.width; ++i) {\n                // generate primary ray direction\n                float x = (2 * (i + 0.5) / (float)scene.width - 1) *\n                        imageAspectRatio * scale;\n                float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;\n\n                Vector3f dir = normalize(Vector3f(-x, y, 1));\n                for (int k = 0; k < spp; k++) {\n                    framebuffer[scene.width * j + i] += scene.castRay(Ray(eye_pos, dir), 0) / spp; \n                }\n            }\n            //printf(\"%d\\n\", j);\n            //UpdateProgress(j / (float)scene.height);\n            mtx.lock();\n            UpdateProgress(++finished_width * 1.0 / scene.width);\n            mtx.unlock();\n        }\n        printf(\"ok %d %d\\n\", y_min, y_max);\n    };\n    int block = scene.height / thread_cnt + (scene.height % thread_cnt != 0);\n    std::thread th[thread_cnt];\n    for (int i = 0; i < thread_cnt; i++) {\n        th[i] = std::thread(multiThreadCastRay, i * block, std::min((i + 1) * block - 1, scene.height));\n    }\n    for (int i = 0; i < thread_cnt; i++) th[i].join();\n    UpdateProgress(1.0);\n\n```\n\n### 路径追踪\n\n```cpp\n// Implementation of Path Tracing\nVector3f Scene::castRay(const Ray &ray, int depth) const\n{\n    // TO DO Implement Path Tracing Algorithm here\n    /*\n    shade(p, wo)\n        sampleLight(inter , pdf_light)\n        Get x, ws, NN, emit from inter\n        Shoot a ray from p to x\n        If the ray is not blocked in the middle\n            L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,\n            NN) / |x-p|^2 / pdf_light\n  \n  \n        L_indir = 0.0\n        //Test Russian Roulette with probability RussianRoulette\n        wi = sample(wo, N)\n        Trace a ray r(p, wi)\n        If ray r hit a non-emitting object at q\n            L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)\n            / pdf(wo, wi, N) / RussianRoulette\n  \n        Return L_dir + L_indir\n    */\n\n    Vector3f L_dir(0, 0, 0), L_indir(0, 0, 0);\n    //ray wo is screen to p, now find p and see if already hit light\n    Ray wo = ray;\n    Intersection p_inter = this->intersect(wo);\n    //if hit nothing\n    if (!p_inter.happened) return L_dir;\n    //if hit light source\n    if (p_inter.m->hasEmission()) return p_inter.m->getEmission();\n\n    //otherwise, it hit a object\n\n    //sampleLight(inter , pdf_light)\n    //uniformly sample x from all LIGHTS and get its pdf\n    Intersection x_inter; float x_pdf;\n    sampleLight(x_inter, x_pdf);\n\n    //Get x, ws, Nx, emit from inter \n    //ws is from p to x(light), Np is at p, Nx is at x(light)\n    Vector3f p = p_inter.coords;\n    Vector3f x = x_inter.coords;\n    Vector3f Np = p_inter.normal;\n    Vector3f Nx = x_inter.normal;\n    Vector3f emit = x_inter.emit;  \n\n    //Shoot a ray (ws) from p to x(light) \n    Vector3f ws_dir = (x - p).normalized();\n    Ray ws(p, ws_dir);\n    Intersection ws_inter = this->intersect(ws);\n\n    // If the ray is NOT blocked in the middle\n    //         L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,\n    //         NN) / |x-p|^2 / pdf_light\n    // Else L_dir = 0.0\n\n    //calc length of p - x and ws_inter to see if it is blocked\n    float px_dis = (x - p).norm(), ws_dis = ws_inter.distance;\n    if (px_dis - ws_dis < 0.001) {\n        L_dir = emit \n        * p_inter.m->eval(wo.direction, ws.direction, Np)\n        * dotProduct(ws.direction, Np)      //all vectors were nomorlized\n        * dotProduct(-ws.direction, Nx)     //so dot product is cosine\n        / pow(px_dis, 2)\n        / x_pdf;\n    } // else L_dir = 0; no need\n  \n    // Now calculate L_indir\n    // Test Russian Roulette with probability RussianRoulette\n    float P_rand = get_random_float();\n    if (P_rand < RussianRoulette) {\n        //wi = sample(wo, N)\n        //wi is from p to q\n        Vector3f wi_dir = p_inter.m->sample(wo.direction, Np).normalized();\n        Ray wi(p_inter.coords, wi_dir);\n        // Trace a ray r(p, wi)\n        // If ray r hit a non-emitting object at q\n        //     L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)\n        //     / pdf(wo, wi, N) / RussianRoulette\n        Intersection wi_inter = this->intersect(wi);\n        if (wi_inter.happened && !(wi_inter.m->hasEmission())) {\n            L_indir = castRay(wi, depth + 1)\n            * p_inter.m->eval(wo.direction, wi.direction, Np)\n            * dotProduct(wi.direction, Np)\n            / p_inter.m->pdf(wo.direction, wi.direction, Np)\n            / RussianRoulette;\n        }\n    }\n    return L_dir + L_indir;\n}\n```\n","source":"_posts/GAMES101-作业7-路径追踪-踩坑指南.md","raw":"---\ntitle: GAMES101 作业7 路径追踪 踩坑指南\ndate: 2024-04-16 13:35:32\ntags: 图形学\n---\n\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n首先回顾路径追踪的原理，如下图\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121322581-1913642501.png\" alt=\"1713229011326\" style=\"zoom:50%;\" />\n\n\n## 基本思想\n\nwo是射向眼镜（相机）的光线，包含来自光源的直接光照ws，来自其他物体的间接光照wi两部分。\n\n在实现path tracing时，我们考虑的是黄色线的方向，即光线从相机射向p点（实际上是从p点射向相机），然后通过多次随机采样从p点射出（实际上是射向p点）的光线得到该像素点的真实颜色。\n\n为了提高效率，将射向p的光线分为ws(光源)和wi（其他物体）计算。由于wi、ws分开计算，因此如果ws被物体挡住,或者wi打到光源均不计算。\n\nwi需要递归计算，通过神奇的Russian Roulette在减少递归层数的同时保持光照的期望不变。\n\n然后按照作业指南上的伪代码写就可以了\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121328730-1409855486.png\" alt=\"1713230279835\" style=\"zoom:80%;\" />\n\n\n\n## 注意事项\n\n- 右墙壁发黑：检查Bound3::IntersectP, `return t_enter <= t_exit && t_exit >= 0;` 就可以\n- 小正方体右上角有三角形黑块:检查Triangle::getIntersectionin Triangle.hpp，当时间小于0时不能判定为相交\n- 多线程：注意framebuffer的下标应该由m改为直接用i和j计算。CMakeLists.txt加一行 `TARGET_LINK_LIBRARIES(RayTracing pthread)`就好。\n\n## 代码\n\n### 多线程优化\n\n```cpp\n    // change the spp value to change sample ammount\n    int spp = 32; // default:16\n    std::cout << \"SPP: \" << spp << \"\\n\";\n\n    // for (uint32_t j = 0; j < scene.height; ++j) {\n    //     for (uint32_t i = 0; i < scene.width; ++i) {\n    //         // generate primary ray direction\n    //         float x = (2 * (i + 0.5) / (float)scene.width - 1) *\n    //                   imageAspectRatio * scale;\n    //         float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;\n\n    //         Vector3f dir = normalize(Vector3f(-x, y, 1));\n    //         for (int k = 0; k < spp; k++){\n    //             framebuffer[m] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  \n    //         }\n    //         m++;\n    //     }\n    //     UpdateProgress(j / (float)scene.height);\n    // }\n    // UpdateProgress(1.f);\n\n    const int thread_cnt = 12;\n    int finished_thread = 0;\n    int finished_width = 0;\n    std::mutex mtx;\n  \n    printf(\"%d %d\\n\", scene.height, scene.width);\n    auto multiThreadCastRay = [&](uint32_t y_min, uint32_t y_max) \n    {\n        printf(\"start %d %d\\n\", y_min, y_max);\n        for (uint32_t j = y_min; j <= y_max; ++j) {\n            for (uint32_t i = 0; i < scene.width; ++i) {\n                // generate primary ray direction\n                float x = (2 * (i + 0.5) / (float)scene.width - 1) *\n                        imageAspectRatio * scale;\n                float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;\n\n                Vector3f dir = normalize(Vector3f(-x, y, 1));\n                for (int k = 0; k < spp; k++) {\n                    framebuffer[scene.width * j + i] += scene.castRay(Ray(eye_pos, dir), 0) / spp; \n                }\n            }\n            //printf(\"%d\\n\", j);\n            //UpdateProgress(j / (float)scene.height);\n            mtx.lock();\n            UpdateProgress(++finished_width * 1.0 / scene.width);\n            mtx.unlock();\n        }\n        printf(\"ok %d %d\\n\", y_min, y_max);\n    };\n    int block = scene.height / thread_cnt + (scene.height % thread_cnt != 0);\n    std::thread th[thread_cnt];\n    for (int i = 0; i < thread_cnt; i++) {\n        th[i] = std::thread(multiThreadCastRay, i * block, std::min((i + 1) * block - 1, scene.height));\n    }\n    for (int i = 0; i < thread_cnt; i++) th[i].join();\n    UpdateProgress(1.0);\n\n```\n\n### 路径追踪\n\n```cpp\n// Implementation of Path Tracing\nVector3f Scene::castRay(const Ray &ray, int depth) const\n{\n    // TO DO Implement Path Tracing Algorithm here\n    /*\n    shade(p, wo)\n        sampleLight(inter , pdf_light)\n        Get x, ws, NN, emit from inter\n        Shoot a ray from p to x\n        If the ray is not blocked in the middle\n            L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,\n            NN) / |x-p|^2 / pdf_light\n  \n  \n        L_indir = 0.0\n        //Test Russian Roulette with probability RussianRoulette\n        wi = sample(wo, N)\n        Trace a ray r(p, wi)\n        If ray r hit a non-emitting object at q\n            L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)\n            / pdf(wo, wi, N) / RussianRoulette\n  \n        Return L_dir + L_indir\n    */\n\n    Vector3f L_dir(0, 0, 0), L_indir(0, 0, 0);\n    //ray wo is screen to p, now find p and see if already hit light\n    Ray wo = ray;\n    Intersection p_inter = this->intersect(wo);\n    //if hit nothing\n    if (!p_inter.happened) return L_dir;\n    //if hit light source\n    if (p_inter.m->hasEmission()) return p_inter.m->getEmission();\n\n    //otherwise, it hit a object\n\n    //sampleLight(inter , pdf_light)\n    //uniformly sample x from all LIGHTS and get its pdf\n    Intersection x_inter; float x_pdf;\n    sampleLight(x_inter, x_pdf);\n\n    //Get x, ws, Nx, emit from inter \n    //ws is from p to x(light), Np is at p, Nx is at x(light)\n    Vector3f p = p_inter.coords;\n    Vector3f x = x_inter.coords;\n    Vector3f Np = p_inter.normal;\n    Vector3f Nx = x_inter.normal;\n    Vector3f emit = x_inter.emit;  \n\n    //Shoot a ray (ws) from p to x(light) \n    Vector3f ws_dir = (x - p).normalized();\n    Ray ws(p, ws_dir);\n    Intersection ws_inter = this->intersect(ws);\n\n    // If the ray is NOT blocked in the middle\n    //         L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,\n    //         NN) / |x-p|^2 / pdf_light\n    // Else L_dir = 0.0\n\n    //calc length of p - x and ws_inter to see if it is blocked\n    float px_dis = (x - p).norm(), ws_dis = ws_inter.distance;\n    if (px_dis - ws_dis < 0.001) {\n        L_dir = emit \n        * p_inter.m->eval(wo.direction, ws.direction, Np)\n        * dotProduct(ws.direction, Np)      //all vectors were nomorlized\n        * dotProduct(-ws.direction, Nx)     //so dot product is cosine\n        / pow(px_dis, 2)\n        / x_pdf;\n    } // else L_dir = 0; no need\n  \n    // Now calculate L_indir\n    // Test Russian Roulette with probability RussianRoulette\n    float P_rand = get_random_float();\n    if (P_rand < RussianRoulette) {\n        //wi = sample(wo, N)\n        //wi is from p to q\n        Vector3f wi_dir = p_inter.m->sample(wo.direction, Np).normalized();\n        Ray wi(p_inter.coords, wi_dir);\n        // Trace a ray r(p, wi)\n        // If ray r hit a non-emitting object at q\n        //     L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)\n        //     / pdf(wo, wi, N) / RussianRoulette\n        Intersection wi_inter = this->intersect(wi);\n        if (wi_inter.happened && !(wi_inter.m->hasEmission())) {\n            L_indir = castRay(wi, depth + 1)\n            * p_inter.m->eval(wo.direction, wi.direction, Np)\n            * dotProduct(wi.direction, Np)\n            / p_inter.m->pdf(wo.direction, wi.direction, Np)\n            / RussianRoulette;\n        }\n    }\n    return L_dir + L_indir;\n}\n```\n","slug":"GAMES101-作业7-路径追踪-踩坑指南","published":1,"updated":"2025-08-26T06:13:21.743Z","comments":1,"layout":"post","photos":[],"_id":"cmes8p3660001lkw9b9z3912v","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n<p>首先回顾路径追踪的原理，如下图</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121322581-1913642501.png\" alt=\"1713229011326\" style=\"zoom:50%;\">\n\n\n<h2 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h2><p>wo是射向眼镜（相机）的光线，包含来自光源的直接光照ws，来自其他物体的间接光照wi两部分。</p>\n<p>在实现path tracing时，我们考虑的是黄色线的方向，即光线从相机射向p点（实际上是从p点射向相机），然后通过多次随机采样从p点射出（实际上是射向p点）的光线得到该像素点的真实颜色。</p>\n<p>为了提高效率，将射向p的光线分为ws(光源)和wi（其他物体）计算。由于wi、ws分开计算，因此如果ws被物体挡住,或者wi打到光源均不计算。</p>\n<p>wi需要递归计算，通过神奇的Russian Roulette在减少递归层数的同时保持光照的期望不变。</p>\n<p>然后按照作业指南上的伪代码写就可以了</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121328730-1409855486.png\" alt=\"1713230279835\" style=\"zoom:80%;\">\n\n\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li>右墙壁发黑：检查Bound3::IntersectP, <code>return t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= 0;</code> 就可以</li>\n<li>小正方体右上角有三角形黑块:检查Triangle::getIntersectionin Triangle.hpp，当时间小于0时不能判定为相交</li>\n<li>多线程：注意framebuffer的下标应该由m改为直接用i和j计算。CMakeLists.txt加一行 <code>TARGET_LINK_LIBRARIES(RayTracing pthread)</code>就好。</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"多线程优化\"><a href=\"#多线程优化\" class=\"headerlink\" title=\"多线程优化\"></a>多线程优化</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// change the spp value to change sample ammount</span></span><br><span class=\"line\"><span class=\"type\">int</span> spp = <span class=\"number\">32</span>; <span class=\"comment\">// default:16</span></span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;SPP: &quot;</span> &lt;&lt; spp &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for (uint32_t j = 0; j &lt; scene.height; ++j) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     for (uint32_t i = 0; i &lt; scene.width; ++i) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         // generate primary ray direction</span></span><br><span class=\"line\"><span class=\"comment\">//         float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class=\"line\"><span class=\"comment\">//                   imageAspectRatio * scale;</span></span><br><span class=\"line\"><span class=\"comment\">//         float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class=\"line\"><span class=\"comment\">//         for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             framebuffer[m] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         m++;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     UpdateProgress(j / (float)scene.height);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// UpdateProgress(1.f);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> thread_cnt = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> finished_thread = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> finished_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">std::mutex mtx;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, scene.height, scene.width);</span><br><span class=\"line\"><span class=\"keyword\">auto</span> multiThreadCastRay = [&amp;](<span class=\"type\">uint32_t</span> y_min, <span class=\"type\">uint32_t</span> y_max) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start %d %d\\n&quot;</span>, y_min, y_max);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> j = y_min; j &lt;= y_max; ++j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; scene.width; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// generate primary ray direction</span></span><br><span class=\"line\">            <span class=\"type\">float</span> x = (<span class=\"number\">2</span> * (i + <span class=\"number\">0.5</span>) / (<span class=\"type\">float</span>)scene.width - <span class=\"number\">1</span>) *</span><br><span class=\"line\">                    imageAspectRatio * scale;</span><br><span class=\"line\">            <span class=\"type\">float</span> y = (<span class=\"number\">1</span> - <span class=\"number\">2</span> * (j + <span class=\"number\">0.5</span>) / (<span class=\"type\">float</span>)scene.height) * scale;</span><br><span class=\"line\"></span><br><span class=\"line\">            Vector3f dir = <span class=\"built_in\">normalize</span>(<span class=\"built_in\">Vector3f</span>(-x, y, <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; spp; k++) &#123;</span><br><span class=\"line\">                framebuffer[scene.width * j + i] += scene.<span class=\"built_in\">castRay</span>(<span class=\"built_in\">Ray</span>(eye_pos, dir), <span class=\"number\">0</span>) / spp; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//printf(&quot;%d\\n&quot;, j);</span></span><br><span class=\"line\">        <span class=\"comment\">//UpdateProgress(j / (float)scene.height);</span></span><br><span class=\"line\">        mtx.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"built_in\">UpdateProgress</span>(++finished_width * <span class=\"number\">1.0</span> / scene.width);</span><br><span class=\"line\">        mtx.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d %d\\n&quot;</span>, y_min, y_max);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> block = scene.height / thread_cnt + (scene.height % thread_cnt != <span class=\"number\">0</span>);</span><br><span class=\"line\">std::thread th[thread_cnt];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; thread_cnt; i++) &#123;</span><br><span class=\"line\">    th[i] = std::<span class=\"built_in\">thread</span>(multiThreadCastRay, i * block, std::<span class=\"built_in\">min</span>((i + <span class=\"number\">1</span>) * block - <span class=\"number\">1</span>, scene.height));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; thread_cnt; i++) th[i].<span class=\"built_in\">join</span>();</span><br><span class=\"line\"><span class=\"built_in\">UpdateProgress</span>(<span class=\"number\">1.0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"路径追踪\"><a href=\"#路径追踪\" class=\"headerlink\" title=\"路径追踪\"></a>路径追踪</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Implementation of Path Tracing</span></span><br><span class=\"line\"><span class=\"function\">Vector3f <span class=\"title\">Scene::castRay</span><span class=\"params\">(<span class=\"type\">const</span> Ray &amp;ray, <span class=\"type\">int</span> depth)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TO DO Implement Path Tracing Algorithm here</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    shade(p, wo)</span></span><br><span class=\"line\"><span class=\"comment\">        sampleLight(inter , pdf_light)</span></span><br><span class=\"line\"><span class=\"comment\">        Get x, ws, NN, emit from inter</span></span><br><span class=\"line\"><span class=\"comment\">        Shoot a ray from p to x</span></span><br><span class=\"line\"><span class=\"comment\">        If the ray is not blocked in the middle</span></span><br><span class=\"line\"><span class=\"comment\">            L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,</span></span><br><span class=\"line\"><span class=\"comment\">            NN) / |x-p|^2 / pdf_light</span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">        L_indir = 0.0</span></span><br><span class=\"line\"><span class=\"comment\">        //Test Russian Roulette with probability RussianRoulette</span></span><br><span class=\"line\"><span class=\"comment\">        wi = sample(wo, N)</span></span><br><span class=\"line\"><span class=\"comment\">        Trace a ray r(p, wi)</span></span><br><span class=\"line\"><span class=\"comment\">        If ray r hit a non-emitting object at q</span></span><br><span class=\"line\"><span class=\"comment\">            L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)</span></span><br><span class=\"line\"><span class=\"comment\">            / pdf(wo, wi, N) / RussianRoulette</span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">        Return L_dir + L_indir</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Vector3f <span class=\"title\">L_dir</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span>, <span class=\"title\">L_indir</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//ray wo is screen to p, now find p and see if already hit light</span></span><br><span class=\"line\">    Ray wo = ray;</span><br><span class=\"line\">    Intersection p_inter = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">intersect</span>(wo);</span><br><span class=\"line\">    <span class=\"comment\">//if hit nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p_inter.happened) <span class=\"keyword\">return</span> L_dir;</span><br><span class=\"line\">    <span class=\"comment\">//if hit light source</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p_inter.m-&gt;<span class=\"built_in\">hasEmission</span>()) <span class=\"keyword\">return</span> p_inter.m-&gt;<span class=\"built_in\">getEmission</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//otherwise, it hit a object</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//sampleLight(inter , pdf_light)</span></span><br><span class=\"line\">    <span class=\"comment\">//uniformly sample x from all LIGHTS and get its pdf</span></span><br><span class=\"line\">    Intersection x_inter; <span class=\"type\">float</span> x_pdf;</span><br><span class=\"line\">    <span class=\"built_in\">sampleLight</span>(x_inter, x_pdf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Get x, ws, Nx, emit from inter </span></span><br><span class=\"line\">    <span class=\"comment\">//ws is from p to x(light), Np is at p, Nx is at x(light)</span></span><br><span class=\"line\">    Vector3f p = p_inter.coords;</span><br><span class=\"line\">    Vector3f x = x_inter.coords;</span><br><span class=\"line\">    Vector3f Np = p_inter.normal;</span><br><span class=\"line\">    Vector3f Nx = x_inter.normal;</span><br><span class=\"line\">    Vector3f emit = x_inter.emit;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Shoot a ray (ws) from p to x(light) </span></span><br><span class=\"line\">    Vector3f ws_dir = (x - p).<span class=\"built_in\">normalized</span>();</span><br><span class=\"line\">    <span class=\"function\">Ray <span class=\"title\">ws</span><span class=\"params\">(p, ws_dir)</span></span>;</span><br><span class=\"line\">    Intersection ws_inter = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">intersect</span>(ws);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the ray is NOT blocked in the middle</span></span><br><span class=\"line\">    <span class=\"comment\">//         L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,</span></span><br><span class=\"line\">    <span class=\"comment\">//         NN) / |x-p|^2 / pdf_light</span></span><br><span class=\"line\">    <span class=\"comment\">// Else L_dir = 0.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//calc length of p - x and ws_inter to see if it is blocked</span></span><br><span class=\"line\">    <span class=\"type\">float</span> px_dis = (x - p).<span class=\"built_in\">norm</span>(), ws_dis = ws_inter.distance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (px_dis - ws_dis &lt; <span class=\"number\">0.001</span>) &#123;</span><br><span class=\"line\">        L_dir = emit </span><br><span class=\"line\">        * p_inter.m-&gt;<span class=\"built_in\">eval</span>(wo.direction, ws.direction, Np)</span><br><span class=\"line\">        * <span class=\"built_in\">dotProduct</span>(ws.direction, Np)      <span class=\"comment\">//all vectors were nomorlized</span></span><br><span class=\"line\">        * <span class=\"built_in\">dotProduct</span>(-ws.direction, Nx)     <span class=\"comment\">//so dot product is cosine</span></span><br><span class=\"line\">        / <span class=\"built_in\">pow</span>(px_dis, <span class=\"number\">2</span>)</span><br><span class=\"line\">        / x_pdf;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// else L_dir = 0; no need</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// Now calculate L_indir</span></span><br><span class=\"line\">    <span class=\"comment\">// Test Russian Roulette with probability RussianRoulette</span></span><br><span class=\"line\">    <span class=\"type\">float</span> P_rand = <span class=\"built_in\">get_random_float</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (P_rand &lt; RussianRoulette) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//wi = sample(wo, N)</span></span><br><span class=\"line\">        <span class=\"comment\">//wi is from p to q</span></span><br><span class=\"line\">        Vector3f wi_dir = p_inter.m-&gt;<span class=\"built_in\">sample</span>(wo.direction, Np).<span class=\"built_in\">normalized</span>();</span><br><span class=\"line\">        <span class=\"function\">Ray <span class=\"title\">wi</span><span class=\"params\">(p_inter.coords, wi_dir)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// Trace a ray r(p, wi)</span></span><br><span class=\"line\">        <span class=\"comment\">// If ray r hit a non-emitting object at q</span></span><br><span class=\"line\">        <span class=\"comment\">//     L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)</span></span><br><span class=\"line\">        <span class=\"comment\">//     / pdf(wo, wi, N) / RussianRoulette</span></span><br><span class=\"line\">        Intersection wi_inter = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">intersect</span>(wi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wi_inter.happened &amp;&amp; !(wi_inter.m-&gt;<span class=\"built_in\">hasEmission</span>())) &#123;</span><br><span class=\"line\">            L_indir = <span class=\"built_in\">castRay</span>(wi, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">            * p_inter.m-&gt;<span class=\"built_in\">eval</span>(wo.direction, wi.direction, Np)</span><br><span class=\"line\">            * <span class=\"built_in\">dotProduct</span>(wi.direction, Np)</span><br><span class=\"line\">            / p_inter.m-&gt;<span class=\"built_in\">pdf</span>(wo.direction, wi.direction, Np)</span><br><span class=\"line\">            / RussianRoulette;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L_dir + L_indir;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n<p>首先回顾路径追踪的原理，如下图</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121322581-1913642501.png\" alt=\"1713229011326\" style=\"zoom:50%;\">\n\n\n<h2 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h2><p>wo是射向眼镜（相机）的光线，包含来自光源的直接光照ws，来自其他物体的间接光照wi两部分。</p>\n<p>在实现path tracing时，我们考虑的是黄色线的方向，即光线从相机射向p点（实际上是从p点射向相机），然后通过多次随机采样从p点射出（实际上是射向p点）的光线得到该像素点的真实颜色。</p>\n<p>为了提高效率，将射向p的光线分为ws(光源)和wi（其他物体）计算。由于wi、ws分开计算，因此如果ws被物体挡住,或者wi打到光源均不计算。</p>\n<p>wi需要递归计算，通过神奇的Russian Roulette在减少递归层数的同时保持光照的期望不变。</p>\n<p>然后按照作业指南上的伪代码写就可以了</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240416121328730-1409855486.png\" alt=\"1713230279835\" style=\"zoom:80%;\">\n\n\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li>右墙壁发黑：检查Bound3::IntersectP, <code>return t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= 0;</code> 就可以</li>\n<li>小正方体右上角有三角形黑块:检查Triangle::getIntersectionin Triangle.hpp，当时间小于0时不能判定为相交</li>\n<li>多线程：注意framebuffer的下标应该由m改为直接用i和j计算。CMakeLists.txt加一行 <code>TARGET_LINK_LIBRARIES(RayTracing pthread)</code>就好。</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"多线程优化\"><a href=\"#多线程优化\" class=\"headerlink\" title=\"多线程优化\"></a>多线程优化</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// change the spp value to change sample ammount</span></span><br><span class=\"line\"><span class=\"type\">int</span> spp = <span class=\"number\">32</span>; <span class=\"comment\">// default:16</span></span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;SPP: &quot;</span> &lt;&lt; spp &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for (uint32_t j = 0; j &lt; scene.height; ++j) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     for (uint32_t i = 0; i &lt; scene.width; ++i) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         // generate primary ray direction</span></span><br><span class=\"line\"><span class=\"comment\">//         float x = (2 * (i + 0.5) / (float)scene.width - 1) *</span></span><br><span class=\"line\"><span class=\"comment\">//                   imageAspectRatio * scale;</span></span><br><span class=\"line\"><span class=\"comment\">//         float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         Vector3f dir = normalize(Vector3f(-x, y, 1));</span></span><br><span class=\"line\"><span class=\"comment\">//         for (int k = 0; k &lt; spp; k++)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             framebuffer[m] += scene.castRay(Ray(eye_pos, dir), 0) / spp;  </span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         m++;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     UpdateProgress(j / (float)scene.height);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// UpdateProgress(1.f);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> thread_cnt = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> finished_thread = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> finished_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">std::mutex mtx;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, scene.height, scene.width);</span><br><span class=\"line\"><span class=\"keyword\">auto</span> multiThreadCastRay = [&amp;](<span class=\"type\">uint32_t</span> y_min, <span class=\"type\">uint32_t</span> y_max) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;start %d %d\\n&quot;</span>, y_min, y_max);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> j = y_min; j &lt;= y_max; ++j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">uint32_t</span> i = <span class=\"number\">0</span>; i &lt; scene.width; ++i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// generate primary ray direction</span></span><br><span class=\"line\">            <span class=\"type\">float</span> x = (<span class=\"number\">2</span> * (i + <span class=\"number\">0.5</span>) / (<span class=\"type\">float</span>)scene.width - <span class=\"number\">1</span>) *</span><br><span class=\"line\">                    imageAspectRatio * scale;</span><br><span class=\"line\">            <span class=\"type\">float</span> y = (<span class=\"number\">1</span> - <span class=\"number\">2</span> * (j + <span class=\"number\">0.5</span>) / (<span class=\"type\">float</span>)scene.height) * scale;</span><br><span class=\"line\"></span><br><span class=\"line\">            Vector3f dir = <span class=\"built_in\">normalize</span>(<span class=\"built_in\">Vector3f</span>(-x, y, <span class=\"number\">1</span>));</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; spp; k++) &#123;</span><br><span class=\"line\">                framebuffer[scene.width * j + i] += scene.<span class=\"built_in\">castRay</span>(<span class=\"built_in\">Ray</span>(eye_pos, dir), <span class=\"number\">0</span>) / spp; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//printf(&quot;%d\\n&quot;, j);</span></span><br><span class=\"line\">        <span class=\"comment\">//UpdateProgress(j / (float)scene.height);</span></span><br><span class=\"line\">        mtx.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"built_in\">UpdateProgress</span>(++finished_width * <span class=\"number\">1.0</span> / scene.width);</span><br><span class=\"line\">        mtx.<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d %d\\n&quot;</span>, y_min, y_max);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> block = scene.height / thread_cnt + (scene.height % thread_cnt != <span class=\"number\">0</span>);</span><br><span class=\"line\">std::thread th[thread_cnt];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; thread_cnt; i++) &#123;</span><br><span class=\"line\">    th[i] = std::<span class=\"built_in\">thread</span>(multiThreadCastRay, i * block, std::<span class=\"built_in\">min</span>((i + <span class=\"number\">1</span>) * block - <span class=\"number\">1</span>, scene.height));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; thread_cnt; i++) th[i].<span class=\"built_in\">join</span>();</span><br><span class=\"line\"><span class=\"built_in\">UpdateProgress</span>(<span class=\"number\">1.0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"路径追踪\"><a href=\"#路径追踪\" class=\"headerlink\" title=\"路径追踪\"></a>路径追踪</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Implementation of Path Tracing</span></span><br><span class=\"line\"><span class=\"function\">Vector3f <span class=\"title\">Scene::castRay</span><span class=\"params\">(<span class=\"type\">const</span> Ray &amp;ray, <span class=\"type\">int</span> depth)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TO DO Implement Path Tracing Algorithm here</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    shade(p, wo)</span></span><br><span class=\"line\"><span class=\"comment\">        sampleLight(inter , pdf_light)</span></span><br><span class=\"line\"><span class=\"comment\">        Get x, ws, NN, emit from inter</span></span><br><span class=\"line\"><span class=\"comment\">        Shoot a ray from p to x</span></span><br><span class=\"line\"><span class=\"comment\">        If the ray is not blocked in the middle</span></span><br><span class=\"line\"><span class=\"comment\">            L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,</span></span><br><span class=\"line\"><span class=\"comment\">            NN) / |x-p|^2 / pdf_light</span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">        L_indir = 0.0</span></span><br><span class=\"line\"><span class=\"comment\">        //Test Russian Roulette with probability RussianRoulette</span></span><br><span class=\"line\"><span class=\"comment\">        wi = sample(wo, N)</span></span><br><span class=\"line\"><span class=\"comment\">        Trace a ray r(p, wi)</span></span><br><span class=\"line\"><span class=\"comment\">        If ray r hit a non-emitting object at q</span></span><br><span class=\"line\"><span class=\"comment\">            L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)</span></span><br><span class=\"line\"><span class=\"comment\">            / pdf(wo, wi, N) / RussianRoulette</span></span><br><span class=\"line\"><span class=\"comment\">  </span></span><br><span class=\"line\"><span class=\"comment\">        Return L_dir + L_indir</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Vector3f <span class=\"title\">L_dir</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span>, <span class=\"title\">L_indir</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//ray wo is screen to p, now find p and see if already hit light</span></span><br><span class=\"line\">    Ray wo = ray;</span><br><span class=\"line\">    Intersection p_inter = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">intersect</span>(wo);</span><br><span class=\"line\">    <span class=\"comment\">//if hit nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p_inter.happened) <span class=\"keyword\">return</span> L_dir;</span><br><span class=\"line\">    <span class=\"comment\">//if hit light source</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p_inter.m-&gt;<span class=\"built_in\">hasEmission</span>()) <span class=\"keyword\">return</span> p_inter.m-&gt;<span class=\"built_in\">getEmission</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//otherwise, it hit a object</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//sampleLight(inter , pdf_light)</span></span><br><span class=\"line\">    <span class=\"comment\">//uniformly sample x from all LIGHTS and get its pdf</span></span><br><span class=\"line\">    Intersection x_inter; <span class=\"type\">float</span> x_pdf;</span><br><span class=\"line\">    <span class=\"built_in\">sampleLight</span>(x_inter, x_pdf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Get x, ws, Nx, emit from inter </span></span><br><span class=\"line\">    <span class=\"comment\">//ws is from p to x(light), Np is at p, Nx is at x(light)</span></span><br><span class=\"line\">    Vector3f p = p_inter.coords;</span><br><span class=\"line\">    Vector3f x = x_inter.coords;</span><br><span class=\"line\">    Vector3f Np = p_inter.normal;</span><br><span class=\"line\">    Vector3f Nx = x_inter.normal;</span><br><span class=\"line\">    Vector3f emit = x_inter.emit;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Shoot a ray (ws) from p to x(light) </span></span><br><span class=\"line\">    Vector3f ws_dir = (x - p).<span class=\"built_in\">normalized</span>();</span><br><span class=\"line\">    <span class=\"function\">Ray <span class=\"title\">ws</span><span class=\"params\">(p, ws_dir)</span></span>;</span><br><span class=\"line\">    Intersection ws_inter = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">intersect</span>(ws);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the ray is NOT blocked in the middle</span></span><br><span class=\"line\">    <span class=\"comment\">//         L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws,</span></span><br><span class=\"line\">    <span class=\"comment\">//         NN) / |x-p|^2 / pdf_light</span></span><br><span class=\"line\">    <span class=\"comment\">// Else L_dir = 0.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//calc length of p - x and ws_inter to see if it is blocked</span></span><br><span class=\"line\">    <span class=\"type\">float</span> px_dis = (x - p).<span class=\"built_in\">norm</span>(), ws_dis = ws_inter.distance;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (px_dis - ws_dis &lt; <span class=\"number\">0.001</span>) &#123;</span><br><span class=\"line\">        L_dir = emit </span><br><span class=\"line\">        * p_inter.m-&gt;<span class=\"built_in\">eval</span>(wo.direction, ws.direction, Np)</span><br><span class=\"line\">        * <span class=\"built_in\">dotProduct</span>(ws.direction, Np)      <span class=\"comment\">//all vectors were nomorlized</span></span><br><span class=\"line\">        * <span class=\"built_in\">dotProduct</span>(-ws.direction, Nx)     <span class=\"comment\">//so dot product is cosine</span></span><br><span class=\"line\">        / <span class=\"built_in\">pow</span>(px_dis, <span class=\"number\">2</span>)</span><br><span class=\"line\">        / x_pdf;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// else L_dir = 0; no need</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// Now calculate L_indir</span></span><br><span class=\"line\">    <span class=\"comment\">// Test Russian Roulette with probability RussianRoulette</span></span><br><span class=\"line\">    <span class=\"type\">float</span> P_rand = <span class=\"built_in\">get_random_float</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (P_rand &lt; RussianRoulette) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//wi = sample(wo, N)</span></span><br><span class=\"line\">        <span class=\"comment\">//wi is from p to q</span></span><br><span class=\"line\">        Vector3f wi_dir = p_inter.m-&gt;<span class=\"built_in\">sample</span>(wo.direction, Np).<span class=\"built_in\">normalized</span>();</span><br><span class=\"line\">        <span class=\"function\">Ray <span class=\"title\">wi</span><span class=\"params\">(p_inter.coords, wi_dir)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// Trace a ray r(p, wi)</span></span><br><span class=\"line\">        <span class=\"comment\">// If ray r hit a non-emitting object at q</span></span><br><span class=\"line\">        <span class=\"comment\">//     L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N)</span></span><br><span class=\"line\">        <span class=\"comment\">//     / pdf(wo, wi, N) / RussianRoulette</span></span><br><span class=\"line\">        Intersection wi_inter = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">intersect</span>(wi);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wi_inter.happened &amp;&amp; !(wi_inter.m-&gt;<span class=\"built_in\">hasEmission</span>())) &#123;</span><br><span class=\"line\">            L_indir = <span class=\"built_in\">castRay</span>(wi, depth + <span class=\"number\">1</span>)</span><br><span class=\"line\">            * p_inter.m-&gt;<span class=\"built_in\">eval</span>(wo.direction, wi.direction, Np)</span><br><span class=\"line\">            * <span class=\"built_in\">dotProduct</span>(wi.direction, Np)</span><br><span class=\"line\">            / p_inter.m-&gt;<span class=\"built_in\">pdf</span>(wo.direction, wi.direction, Np)</span><br><span class=\"line\">            / RussianRoulette;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L_dir + L_indir;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"GAMES101 作业8 质点弹簧系统 踩坑指南","date":"2024-05-28T10:05:38.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n#### 依赖库安装\n\n使用以下命令安装\n\n```sh\nsudo apt install libglu1-mesa-dev freeglut3-dev mesa-common-dev xorg-dev\n```\n\n**不要直接从pdf上复制命令**，pdf上的横线符号是错误的，会导致 `unable to locate`\n\n#### 段错误\n\n来自[在 Win10 下配置 GAMES101 开发环境（WSL2） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/371080057)\n1.执行\n\n```bash\nexport LIBGL_ALWAYS_INDIRECT=0\n```\n\n2.下载MobaXterm，作为终端启动ropesim\n\n但是，我的MobaXterm中只有一个WSL，上文提到图形界面显示失败的问题并未解决。\n\n下面是通过StackOverflow等摸索而来：\n\n#### **GLFW Error: Linux: Failed to watch for joystick...**\n\n执行\n\n```sh\ntouch ~/.Xauthority \n```\n\n然后重启MobaXterm，\n\n然后执行\n\n```sh\nsudo cp ~/.Xauthority  /root/\n```\n\n然后使用sudo打开ropesim\n\n```sh\nsudo ./ropesim\n```\n\n虽然仍会显示GLFW Error,但能够成功显示窗口。\n\n![image-20240528170135716](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528160139051-1555565421.png)\n\n#### 弹簧乱飞\n\n参考：\n\n[关于作业8的一些问题解答 – 计算机图形学与混合现实在线平台 (games-cn.org)](https://games-cn.org/forums/topic/guanyuzuoye8deyixiewentijieda/)\n\n对于显示欧拉法，是正常的，减小步长（如 `sudo ./ropesim -s 1024` ）可以减缓发散的时间（但还是会发散）\n\n对于Verlet方法，要在计算每个质点后把 `m->forces`清零，上面simulateEuler函数中已经给出，此处需要自己加上。\n\n#### 完整代码\n\n```cpp\n#include <iostream>\n#include <vector>\n\n#include \"CGL/vector2D.h\"\n\n#include \"mass.h\"\n#include \"rope.h\"\n#include \"spring.h\"\n\nnamespace CGL {\n\n    Rope::Rope(Vector2D start, Vector2D end, int num_nodes, float node_mass, float k, vector<int> pinned_nodes)\n    {\n        // TODO (Part 1): Create a rope starting at `start`, ending at `end`, and containing `num_nodes` nodes.\n\n\n        // Def of rope:\n        // vector<Mass *> masses;\n        // vector<Spring *> springs;\n\n        /*\n          Mass(Vector2D position, float mass, bool pinned)\n      : start_position(position), position(position), last_position(position),\n        mass(mass), pinned(pinned) {}\n        Spring(Mass *a, Mass *b, float k)\n      : m1(a), m2(b), k(k), rest_length((a->position - b->position).norm()) {}\n        */\n        for (int i = 0; i < num_nodes; i++) {\n            Vector2D pos = start + (end - start) * (1.0 * i / (num_nodes - 1));\n            masses.emplace_back(new Mass(pos, node_mass, false));\n        }\n\n        for (int i = 0; i < num_nodes - 1; i++) {\n            springs.emplace_back(new Spring(masses[i], masses[i + 1], k));\n        } \n\n        // Comment-in this part when you implement the constructor\n        for (auto &i : pinned_nodes) {\n            masses[i]->pinned = true;\n        }\n    }\n\n    void Rope::simulateEuler(float delta_t, Vector2D gravity)\n    {\n        for (auto &s : springs)\n        {\n            // TODO (Part 2): Use Hooke's law to calculate the force on a node\n            auto len = (s->m1->position - s->m2->position).norm();\n            s->m1->forces += - s->k * (s->m1->position - s->m2->position) / len * (len - s->rest_length);\n            s->m2->forces += - s->k * (s->m2->position - s->m1->position) / len * (len - s->rest_length);\n        }\n\n        for (auto &m : masses)\n        {\n            if (!m->pinned)\n            {\n                // TODO (Part 2): Add the force due to gravity, then compute the new velocity and position\n                auto a = m->forces / m->mass + gravity;\n                float kd = 0.005; a += - kd * m->velocity / m->mass;  // TODO (Part 2): Add global damping\n                auto v_t = m->velocity;\n                m->velocity += a * delta_t;\n                //m->position += v_t * delta_t;  //Explicit Method 不收敛\n                m->position += m->velocity * delta_t; // Semi-implicit method\n            }\n\n            // Reset all forces on each mass\n            m->forces = Vector2D(0, 0);\n        }\n    }\n\n    void Rope::simulateVerlet(float delta_t, Vector2D gravity)\n    {\n        for (auto &s : springs)\n        {\n            // TODO (Part 3): Simulate one timestep of the rope using explicit Verlet （solving constraints)\n            auto len = (s->m1->position - s->m2->position).norm();\n            s->m1->forces += -s->k * (s->m1->position - s->m2->position) / len * (len - s->rest_length);\n            s->m2->forces += -s->k * (s->m2->position - s->m1->position) / len * (len - s->rest_length);\n        }\n\n        for (auto &m : masses)\n        {\n            if (!m->pinned)\n            {\n                Vector2D temp_position = m->position;\n                // TODO (Part 3.1): Set the new position of the rope mass\n                // TODO (Part 4): Add global Verlet damping\n                auto a = m->forces / m->mass + gravity;\n                float damping_factor = 0.00000000005;\n                m->position = temp_position + (1 - damping_factor) * (temp_position - m->last_position) + a * delta_t * delta_t; \n                m->last_position = temp_position;\n            }\n            m->forces = Vector2D(0, 0);\n        }\n    }\n}\n\n```\n\n![image-20240528180227291](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528170229905-433311491.png)\n","source":"_posts/GAMES101-作业8-质点弹簧系统-踩坑指南.md","raw":"---\ntitle: GAMES101 作业8 质点弹簧系统 踩坑指南\ndate: 2024-05-28 18:05:38\ntags: 图形学\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n\n#### 依赖库安装\n\n使用以下命令安装\n\n```sh\nsudo apt install libglu1-mesa-dev freeglut3-dev mesa-common-dev xorg-dev\n```\n\n**不要直接从pdf上复制命令**，pdf上的横线符号是错误的，会导致 `unable to locate`\n\n#### 段错误\n\n来自[在 Win10 下配置 GAMES101 开发环境（WSL2） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/371080057)\n1.执行\n\n```bash\nexport LIBGL_ALWAYS_INDIRECT=0\n```\n\n2.下载MobaXterm，作为终端启动ropesim\n\n但是，我的MobaXterm中只有一个WSL，上文提到图形界面显示失败的问题并未解决。\n\n下面是通过StackOverflow等摸索而来：\n\n#### **GLFW Error: Linux: Failed to watch for joystick...**\n\n执行\n\n```sh\ntouch ~/.Xauthority \n```\n\n然后重启MobaXterm，\n\n然后执行\n\n```sh\nsudo cp ~/.Xauthority  /root/\n```\n\n然后使用sudo打开ropesim\n\n```sh\nsudo ./ropesim\n```\n\n虽然仍会显示GLFW Error,但能够成功显示窗口。\n\n![image-20240528170135716](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528160139051-1555565421.png)\n\n#### 弹簧乱飞\n\n参考：\n\n[关于作业8的一些问题解答 – 计算机图形学与混合现实在线平台 (games-cn.org)](https://games-cn.org/forums/topic/guanyuzuoye8deyixiewentijieda/)\n\n对于显示欧拉法，是正常的，减小步长（如 `sudo ./ropesim -s 1024` ）可以减缓发散的时间（但还是会发散）\n\n对于Verlet方法，要在计算每个质点后把 `m->forces`清零，上面simulateEuler函数中已经给出，此处需要自己加上。\n\n#### 完整代码\n\n```cpp\n#include <iostream>\n#include <vector>\n\n#include \"CGL/vector2D.h\"\n\n#include \"mass.h\"\n#include \"rope.h\"\n#include \"spring.h\"\n\nnamespace CGL {\n\n    Rope::Rope(Vector2D start, Vector2D end, int num_nodes, float node_mass, float k, vector<int> pinned_nodes)\n    {\n        // TODO (Part 1): Create a rope starting at `start`, ending at `end`, and containing `num_nodes` nodes.\n\n\n        // Def of rope:\n        // vector<Mass *> masses;\n        // vector<Spring *> springs;\n\n        /*\n          Mass(Vector2D position, float mass, bool pinned)\n      : start_position(position), position(position), last_position(position),\n        mass(mass), pinned(pinned) {}\n        Spring(Mass *a, Mass *b, float k)\n      : m1(a), m2(b), k(k), rest_length((a->position - b->position).norm()) {}\n        */\n        for (int i = 0; i < num_nodes; i++) {\n            Vector2D pos = start + (end - start) * (1.0 * i / (num_nodes - 1));\n            masses.emplace_back(new Mass(pos, node_mass, false));\n        }\n\n        for (int i = 0; i < num_nodes - 1; i++) {\n            springs.emplace_back(new Spring(masses[i], masses[i + 1], k));\n        } \n\n        // Comment-in this part when you implement the constructor\n        for (auto &i : pinned_nodes) {\n            masses[i]->pinned = true;\n        }\n    }\n\n    void Rope::simulateEuler(float delta_t, Vector2D gravity)\n    {\n        for (auto &s : springs)\n        {\n            // TODO (Part 2): Use Hooke's law to calculate the force on a node\n            auto len = (s->m1->position - s->m2->position).norm();\n            s->m1->forces += - s->k * (s->m1->position - s->m2->position) / len * (len - s->rest_length);\n            s->m2->forces += - s->k * (s->m2->position - s->m1->position) / len * (len - s->rest_length);\n        }\n\n        for (auto &m : masses)\n        {\n            if (!m->pinned)\n            {\n                // TODO (Part 2): Add the force due to gravity, then compute the new velocity and position\n                auto a = m->forces / m->mass + gravity;\n                float kd = 0.005; a += - kd * m->velocity / m->mass;  // TODO (Part 2): Add global damping\n                auto v_t = m->velocity;\n                m->velocity += a * delta_t;\n                //m->position += v_t * delta_t;  //Explicit Method 不收敛\n                m->position += m->velocity * delta_t; // Semi-implicit method\n            }\n\n            // Reset all forces on each mass\n            m->forces = Vector2D(0, 0);\n        }\n    }\n\n    void Rope::simulateVerlet(float delta_t, Vector2D gravity)\n    {\n        for (auto &s : springs)\n        {\n            // TODO (Part 3): Simulate one timestep of the rope using explicit Verlet （solving constraints)\n            auto len = (s->m1->position - s->m2->position).norm();\n            s->m1->forces += -s->k * (s->m1->position - s->m2->position) / len * (len - s->rest_length);\n            s->m2->forces += -s->k * (s->m2->position - s->m1->position) / len * (len - s->rest_length);\n        }\n\n        for (auto &m : masses)\n        {\n            if (!m->pinned)\n            {\n                Vector2D temp_position = m->position;\n                // TODO (Part 3.1): Set the new position of the rope mass\n                // TODO (Part 4): Add global Verlet damping\n                auto a = m->forces / m->mass + gravity;\n                float damping_factor = 0.00000000005;\n                m->position = temp_position + (1 - damping_factor) * (temp_position - m->last_position) + a * delta_t * delta_t; \n                m->last_position = temp_position;\n            }\n            m->forces = Vector2D(0, 0);\n        }\n    }\n}\n\n```\n\n![image-20240528180227291](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528170229905-433311491.png)\n","slug":"GAMES101-作业8-质点弹簧系统-踩坑指南","published":1,"updated":"2025-08-26T06:13:21.745Z","comments":1,"layout":"post","photos":[],"_id":"cmes8p3690003lkw96mz8cjzd","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<h4 id=\"依赖库安装\"><a href=\"#依赖库安装\" class=\"headerlink\" title=\"依赖库安装\"></a>依赖库安装</h4><p>使用以下命令安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install libglu1-mesa-dev freeglut3-dev mesa-common-dev xorg-dev</span><br></pre></td></tr></table></figure>\n\n<p><strong>不要直接从pdf上复制命令</strong>，pdf上的横线符号是错误的，会导致 <code>unable to locate</code></p>\n<h4 id=\"段错误\"><a href=\"#段错误\" class=\"headerlink\" title=\"段错误\"></a>段错误</h4><p>来自<a href=\"https://zhuanlan.zhihu.com/p/371080057\">在 Win10 下配置 GAMES101 开发环境（WSL2） - 知乎 (zhihu.com)</a><br>1.执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> LIBGL_ALWAYS_INDIRECT=0</span><br></pre></td></tr></table></figure>\n\n<p>2.下载MobaXterm，作为终端启动ropesim</p>\n<p>但是，我的MobaXterm中只有一个WSL，上文提到图形界面显示失败的问题并未解决。</p>\n<p>下面是通过StackOverflow等摸索而来：</p>\n<h4 id=\"GLFW-Error-Linux-Failed-to-watch-for-joystick…\"><a href=\"#GLFW-Error-Linux-Failed-to-watch-for-joystick…\" class=\"headerlink\" title=\"GLFW Error: Linux: Failed to watch for joystick…\"></a><strong>GLFW Error: Linux: Failed to watch for joystick…</strong></h4><p>执行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">touch</span> ~/.Xauthority </span><br></pre></td></tr></table></figure>\n\n<p>然后重启MobaXterm，</p>\n<p>然后执行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">cp</span> ~/.Xauthority  /root/</span><br></pre></td></tr></table></figure>\n\n<p>然后使用sudo打开ropesim</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ./ropesim</span><br></pre></td></tr></table></figure>\n\n<p>虽然仍会显示GLFW Error,但能够成功显示窗口。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528160139051-1555565421.png\" alt=\"image-20240528170135716\"></p>\n<h4 id=\"弹簧乱飞\"><a href=\"#弹簧乱飞\" class=\"headerlink\" title=\"弹簧乱飞\"></a>弹簧乱飞</h4><p>参考：</p>\n<p><a href=\"https://games-cn.org/forums/topic/guanyuzuoye8deyixiewentijieda/\">关于作业8的一些问题解答 – 计算机图形学与混合现实在线平台 (games-cn.org)</a></p>\n<p>对于显示欧拉法，是正常的，减小步长（如 <code>sudo ./ropesim -s 1024</code> ）可以减缓发散的时间（但还是会发散）</p>\n<p>对于Verlet方法，要在计算每个质点后把 <code>m-&gt;forces</code>清零，上面simulateEuler函数中已经给出，此处需要自己加上。</p>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;CGL/vector2D.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mass.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;rope.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;spring.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> CGL &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Rope::<span class=\"built_in\">Rope</span>(Vector2D start, Vector2D end, <span class=\"type\">int</span> num_nodes, <span class=\"type\">float</span> node_mass, <span class=\"type\">float</span> k, vector&lt;<span class=\"type\">int</span>&gt; pinned_nodes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO (Part 1): Create a rope starting at `start`, ending at `end`, and containing `num_nodes` nodes.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Def of rope:</span></span><br><span class=\"line\">        <span class=\"comment\">// vector&lt;Mass *&gt; masses;</span></span><br><span class=\"line\">        <span class=\"comment\">// vector&lt;Spring *&gt; springs;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          Mass(Vector2D position, float mass, bool pinned)</span></span><br><span class=\"line\"><span class=\"comment\">      : start_position(position), position(position), last_position(position),</span></span><br><span class=\"line\"><span class=\"comment\">        mass(mass), pinned(pinned) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">        Spring(Mass *a, Mass *b, float k)</span></span><br><span class=\"line\"><span class=\"comment\">      : m1(a), m2(b), k(k), rest_length((a-&gt;position - b-&gt;position).norm()) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num_nodes; i++) &#123;</span><br><span class=\"line\">            Vector2D pos = start + (end - start) * (<span class=\"number\">1.0</span> * i / (num_nodes - <span class=\"number\">1</span>));</span><br><span class=\"line\">            masses.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Mass</span>(pos, node_mass, <span class=\"literal\">false</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num_nodes - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            springs.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Spring</span>(masses[i], masses[i + <span class=\"number\">1</span>], k));</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Comment-in this part when you implement the constructor</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;i : pinned_nodes) &#123;</span><br><span class=\"line\">            masses[i]-&gt;pinned = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Rope::simulateEuler</span><span class=\"params\">(<span class=\"type\">float</span> <span class=\"type\">delta_t</span>, Vector2D gravity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s : springs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO (Part 2): Use Hooke&#x27;s law to calculate the force on a node</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> len = (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position).<span class=\"built_in\">norm</span>();</span><br><span class=\"line\">            s-&gt;m1-&gt;forces += - s-&gt;k * (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">            s-&gt;m2-&gt;forces += - s-&gt;k * (s-&gt;m2-&gt;position - s-&gt;m1-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;m : masses)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!m-&gt;pinned)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO (Part 2): Add the force due to gravity, then compute the new velocity and position</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> a = m-&gt;forces / m-&gt;mass + gravity;</span><br><span class=\"line\">                <span class=\"type\">float</span> kd = <span class=\"number\">0.005</span>; a += - kd * m-&gt;velocity / m-&gt;mass;  <span class=\"comment\">// TODO (Part 2): Add global damping</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> <span class=\"type\">v_t</span> = m-&gt;velocity;</span><br><span class=\"line\">                m-&gt;velocity += a * <span class=\"type\">delta_t</span>;</span><br><span class=\"line\">                <span class=\"comment\">//m-&gt;position += v_t * delta_t;  //Explicit Method 不收敛</span></span><br><span class=\"line\">                m-&gt;position += m-&gt;velocity * <span class=\"type\">delta_t</span>; <span class=\"comment\">// Semi-implicit method</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Reset all forces on each mass</span></span><br><span class=\"line\">            m-&gt;forces = <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Rope::simulateVerlet</span><span class=\"params\">(<span class=\"type\">float</span> <span class=\"type\">delta_t</span>, Vector2D gravity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s : springs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO (Part 3): Simulate one timestep of the rope using explicit Verlet （solving constraints)</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> len = (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position).<span class=\"built_in\">norm</span>();</span><br><span class=\"line\">            s-&gt;m1-&gt;forces += -s-&gt;k * (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">            s-&gt;m2-&gt;forces += -s-&gt;k * (s-&gt;m2-&gt;position - s-&gt;m1-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;m : masses)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!m-&gt;pinned)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Vector2D temp_position = m-&gt;position;</span><br><span class=\"line\">                <span class=\"comment\">// TODO (Part 3.1): Set the new position of the rope mass</span></span><br><span class=\"line\">                <span class=\"comment\">// TODO (Part 4): Add global Verlet damping</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> a = m-&gt;forces / m-&gt;mass + gravity;</span><br><span class=\"line\">                <span class=\"type\">float</span> damping_factor = <span class=\"number\">0.00000000005</span>;</span><br><span class=\"line\">                m-&gt;position = temp_position + (<span class=\"number\">1</span> - damping_factor) * (temp_position - m-&gt;last_position) + a * <span class=\"type\">delta_t</span> * <span class=\"type\">delta_t</span>; </span><br><span class=\"line\">                m-&gt;last_position = temp_position;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m-&gt;forces = <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528170229905-433311491.png\" alt=\"image-20240528180227291\"></p>\n","excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n\n<h4 id=\"依赖库安装\"><a href=\"#依赖库安装\" class=\"headerlink\" title=\"依赖库安装\"></a>依赖库安装</h4><p>使用以下命令安装</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install libglu1-mesa-dev freeglut3-dev mesa-common-dev xorg-dev</span><br></pre></td></tr></table></figure>\n\n<p><strong>不要直接从pdf上复制命令</strong>，pdf上的横线符号是错误的，会导致 <code>unable to locate</code></p>\n<h4 id=\"段错误\"><a href=\"#段错误\" class=\"headerlink\" title=\"段错误\"></a>段错误</h4><p>来自<a href=\"https://zhuanlan.zhihu.com/p/371080057\">在 Win10 下配置 GAMES101 开发环境（WSL2） - 知乎 (zhihu.com)</a><br>1.执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> LIBGL_ALWAYS_INDIRECT=0</span><br></pre></td></tr></table></figure>\n\n<p>2.下载MobaXterm，作为终端启动ropesim</p>\n<p>但是，我的MobaXterm中只有一个WSL，上文提到图形界面显示失败的问题并未解决。</p>\n<p>下面是通过StackOverflow等摸索而来：</p>\n<h4 id=\"GLFW-Error-Linux-Failed-to-watch-for-joystick…\"><a href=\"#GLFW-Error-Linux-Failed-to-watch-for-joystick…\" class=\"headerlink\" title=\"GLFW Error: Linux: Failed to watch for joystick…\"></a><strong>GLFW Error: Linux: Failed to watch for joystick…</strong></h4><p>执行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">touch</span> ~/.Xauthority </span><br></pre></td></tr></table></figure>\n\n<p>然后重启MobaXterm，</p>\n<p>然后执行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">cp</span> ~/.Xauthority  /root/</span><br></pre></td></tr></table></figure>\n\n<p>然后使用sudo打开ropesim</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ./ropesim</span><br></pre></td></tr></table></figure>\n\n<p>虽然仍会显示GLFW Error,但能够成功显示窗口。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528160139051-1555565421.png\" alt=\"image-20240528170135716\"></p>\n<h4 id=\"弹簧乱飞\"><a href=\"#弹簧乱飞\" class=\"headerlink\" title=\"弹簧乱飞\"></a>弹簧乱飞</h4><p>参考：</p>\n<p><a href=\"https://games-cn.org/forums/topic/guanyuzuoye8deyixiewentijieda/\">关于作业8的一些问题解答 – 计算机图形学与混合现实在线平台 (games-cn.org)</a></p>\n<p>对于显示欧拉法，是正常的，减小步长（如 <code>sudo ./ropesim -s 1024</code> ）可以减缓发散的时间（但还是会发散）</p>\n<p>对于Verlet方法，要在计算每个质点后把 <code>m-&gt;forces</code>清零，上面simulateEuler函数中已经给出，此处需要自己加上。</p>\n<h4 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;CGL/vector2D.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mass.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;rope.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;spring.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> CGL &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Rope::<span class=\"built_in\">Rope</span>(Vector2D start, Vector2D end, <span class=\"type\">int</span> num_nodes, <span class=\"type\">float</span> node_mass, <span class=\"type\">float</span> k, vector&lt;<span class=\"type\">int</span>&gt; pinned_nodes)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO (Part 1): Create a rope starting at `start`, ending at `end`, and containing `num_nodes` nodes.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Def of rope:</span></span><br><span class=\"line\">        <span class=\"comment\">// vector&lt;Mass *&gt; masses;</span></span><br><span class=\"line\">        <span class=\"comment\">// vector&lt;Spring *&gt; springs;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          Mass(Vector2D position, float mass, bool pinned)</span></span><br><span class=\"line\"><span class=\"comment\">      : start_position(position), position(position), last_position(position),</span></span><br><span class=\"line\"><span class=\"comment\">        mass(mass), pinned(pinned) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">        Spring(Mass *a, Mass *b, float k)</span></span><br><span class=\"line\"><span class=\"comment\">      : m1(a), m2(b), k(k), rest_length((a-&gt;position - b-&gt;position).norm()) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num_nodes; i++) &#123;</span><br><span class=\"line\">            Vector2D pos = start + (end - start) * (<span class=\"number\">1.0</span> * i / (num_nodes - <span class=\"number\">1</span>));</span><br><span class=\"line\">            masses.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Mass</span>(pos, node_mass, <span class=\"literal\">false</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num_nodes - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            springs.<span class=\"built_in\">emplace_back</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Spring</span>(masses[i], masses[i + <span class=\"number\">1</span>], k));</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Comment-in this part when you implement the constructor</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;i : pinned_nodes) &#123;</span><br><span class=\"line\">            masses[i]-&gt;pinned = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Rope::simulateEuler</span><span class=\"params\">(<span class=\"type\">float</span> <span class=\"type\">delta_t</span>, Vector2D gravity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s : springs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO (Part 2): Use Hooke&#x27;s law to calculate the force on a node</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> len = (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position).<span class=\"built_in\">norm</span>();</span><br><span class=\"line\">            s-&gt;m1-&gt;forces += - s-&gt;k * (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">            s-&gt;m2-&gt;forces += - s-&gt;k * (s-&gt;m2-&gt;position - s-&gt;m1-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;m : masses)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!m-&gt;pinned)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO (Part 2): Add the force due to gravity, then compute the new velocity and position</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> a = m-&gt;forces / m-&gt;mass + gravity;</span><br><span class=\"line\">                <span class=\"type\">float</span> kd = <span class=\"number\">0.005</span>; a += - kd * m-&gt;velocity / m-&gt;mass;  <span class=\"comment\">// TODO (Part 2): Add global damping</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> <span class=\"type\">v_t</span> = m-&gt;velocity;</span><br><span class=\"line\">                m-&gt;velocity += a * <span class=\"type\">delta_t</span>;</span><br><span class=\"line\">                <span class=\"comment\">//m-&gt;position += v_t * delta_t;  //Explicit Method 不收敛</span></span><br><span class=\"line\">                m-&gt;position += m-&gt;velocity * <span class=\"type\">delta_t</span>; <span class=\"comment\">// Semi-implicit method</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Reset all forces on each mass</span></span><br><span class=\"line\">            m-&gt;forces = <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Rope::simulateVerlet</span><span class=\"params\">(<span class=\"type\">float</span> <span class=\"type\">delta_t</span>, Vector2D gravity)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s : springs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// TODO (Part 3): Simulate one timestep of the rope using explicit Verlet （solving constraints)</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> len = (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position).<span class=\"built_in\">norm</span>();</span><br><span class=\"line\">            s-&gt;m1-&gt;forces += -s-&gt;k * (s-&gt;m1-&gt;position - s-&gt;m2-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">            s-&gt;m2-&gt;forces += -s-&gt;k * (s-&gt;m2-&gt;position - s-&gt;m1-&gt;position) / len * (len - s-&gt;rest_length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;m : masses)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!m-&gt;pinned)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                Vector2D temp_position = m-&gt;position;</span><br><span class=\"line\">                <span class=\"comment\">// TODO (Part 3.1): Set the new position of the rope mass</span></span><br><span class=\"line\">                <span class=\"comment\">// TODO (Part 4): Add global Verlet damping</span></span><br><span class=\"line\">                <span class=\"keyword\">auto</span> a = m-&gt;forces / m-&gt;mass + gravity;</span><br><span class=\"line\">                <span class=\"type\">float</span> damping_factor = <span class=\"number\">0.00000000005</span>;</span><br><span class=\"line\">                m-&gt;position = temp_position + (<span class=\"number\">1</span> - damping_factor) * (temp_position - m-&gt;last_position) + a * <span class=\"type\">delta_t</span> * <span class=\"type\">delta_t</span>; </span><br><span class=\"line\">                m-&gt;last_position = temp_position;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            m-&gt;forces = <span class=\"built_in\">Vector2D</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240528170229905-433311491.png\" alt=\"image-20240528180227291\"></p>\n"},{"title":"hello world nya","date":"2024-04-14T07:08:17.000Z","_content":"qwq\n\nqwq\n\nqwq\n\nqwq\n","source":"_posts/hello-world-nya.md","raw":"---\ntitle: hello world nya\ndate: 2024-04-14 15:08:17\ntags:\n---\nqwq\n\nqwq\n\nqwq\n\nqwq\n","slug":"hello-world-nya","published":1,"updated":"2025-08-26T06:13:21.746Z","comments":1,"layout":"post","photos":[],"_id":"cmes8p36b0005lkw98qr427rp","content":"<p>qwq</p>\n<p>qwq</p>\n<p>qwq</p>\n<p>qwq</p>\n","excerpt":"","more":"<p>qwq</p>\n<p>qwq</p>\n<p>qwq</p>\n<p>qwq</p>\n"},{"title":"TinyRendererNotes","date":"2024-05-05T16:41:25.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n## TinyRender学习笔记\n\n通过手写软光栅渲染器加深对计算机图形学基本原理的理解，并练习C++面向对象程序设计。\n\n该项目主要参考[Home · ssloy/tinyrenderer Wiki (github.com)](https://github.com/ssloy/tinyrenderer/wiki)编写，使用CMake构建\n\n可以浏览我的历史commit，找到不同进度时提交的代码。\n\n本项目涉及的几乎所有的图形学知识都在GAMES101课程中出现过，推荐将GAMES101作为前置课程，或配合GAMES101的进度一起学习。\n\n## Lesson 0 Getting Started\n\n### Using TGA image format\n\n使用这个基本框架来生成TGA格式图像：\n[ssloy/tinyrenderer at 909fe20934ba5334144d2c748805690a1fa4c89f (github.com)](https://github.com/ssloy/tinyrenderer/tree/909fe20934ba5334144d2c748805690a1fa4c89f)\n\n只需 `#include \"tgaimage.h\"` ，并在编译时链接tgaimage.cpp即可。\n\n例：在屏幕上将像素(52,41)设置为红色\n\n```cpp\n#include \"tgaimage.h\"\n//Set color with RGB\nconst TGAColor white = TGAColor(255, 255, 255, 255);\nconst TGAColor red   = TGAColor(255, 0,   0,   255);\nint main(int argc, char** argv) {\n    \t//Set image size\n        TGAImage image(100, 100, TGAImage::RGB);\n    \t//Set pixel color\n        image.set(52, 41, red);\n        //To have the origin at the left bottom corner of the image\n        image.flip_vertically(); \n        image.write_tga_file(\"output.tga\");\n        return 0;\n}\n```\n\n个人推荐的环境：Clion + CMake。（因为VsCode CMake调试功能实在搞不懂=.=)\n\n涉及导入模型，需要将工作目录设置为工程文件夹\n\n![image-20240505230016266](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220018544-333214793.png)\n\n![image-20240505230043985](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220047826-450326712.png)\n\n但我的Clion存在tga图像无法加载的bug。在设置->编辑器->文件类型中去掉.tga，然后选择用本地程序打开即可。\n\n## Lesson 1 Bresenham’s Line Drawing Algorithm\n\n使用Bresenham算法绘制线段。\n\n原理：https://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n\n实现参考：https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C++\n\n建议绘制斜率小于-1，-1到0,0到1,大于1，以及水平和垂直的直线来检验算法正确性。\n\n```cpp\n#include <cmath>\n\n#include \"tgaimage.h\"\n\nconst TGAColor white = TGAColor(255, 255, 255, 255);\nconst TGAColor red = TGAColor(255, 0, 0, 255);\nconst TGAColor blue = TGAColor(0, 0, 255, 255);\n\nvoid line(int x1, int y1, int x2, int y2, TGAImage& image, TGAColor color)\n{\n    //Ensure that slope in (0, 1)\n    const bool steep = (std::abs(y2 - y1) > std::abs(x2 - x1));\n    if (steep) {\n        std::swap(x1, y1);\n        std::swap(x2, y2);\n    }\n    if (x1 > x2) {\n        std::swap(x1, x2);\n        std::swap(y1, y2);\n    }\n\n    const float dx = x2 - x1;\n    const float dy = fabs(y2 - y1);\n\n    float error = dx / 2.0f;\n    const int ystep = (y1 < y2) ? 1 : -1;\n    int y = (int)y1;\n\n    const int maxX = (int)x2;\n\n    for (int x = (int)x1; x <= maxX; x++) {\n        if (steep) {\n            image.set(y, x, color);\n        } else {\n            image.set(x, y, color);\n        }\n\n        error -= dy;\n        if (error < 0) {\n            y += ystep;\n            error += dx;\n        }\n    }\n}\n\nint main(int argc, char** argv)\n{\n    TGAImage image(100, 100, TGAImage::RGB);\n    line(13, 20, 80, 40, image, red);\n    line(55, 33, 22, 66, image, blue);\n    line(33, 33, 66, 66, image, white);\n    line(44, 20, 44, 80, image, white);\n    line(20, 44, 80, 44, image, white);\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    return 0;\n}\n\n```\n\n效果\n\n![image-20240419183705501](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419173705372-1981687689.png)\n\n## Lesson 2: Triangle rasterization and back face culling\n\n三维物体模型通常以三角形为基础。为了方便表示点、向量、多边形，写geometry.h。\n\n```cpp\n#pragma once\n\ntemplate <class t> struct Vec2 {\n    union {\n        struct {t u, v;};\n        struct {t x, y;};\n        t raw[2];\n    };\n    Vec2() : u(0), v(0) {}\n    Vec2(t _u, t _v) : u(_u),v(_v) {}\n    inline Vec2<t> operator +(const Vec2<t> &V) const { return Vec2<t>(u+V.u, v+V.v); }\n    inline Vec2<t> operator -(const Vec2<t> &V) const { return Vec2<t>(u-V.u, v-V.v); }\n    inline Vec2<t> operator *(float f)          const { return Vec2<t>(u*f, v*f); }\n    template <class > friend std::ostream& operator<<(std::ostream& s, Vec2<t>& v);\n};\n\ntemplate <class t> struct Vec3 {\n    union {\n        struct {t x, y, z;};\n        struct { t ivert, iuv, inorm; };\n        t raw[3];\n    };\n    Vec3() : x(0), y(0), z(0) {}\n    Vec3(t _x, t _y, t _z) : x(_x),y(_y),z(_z) {}\n    inline Vec3<t> operator ^(const Vec3<t> &v) const { return Vec3<t>(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }\n    inline Vec3<t> operator +(const Vec3<t> &v) const { return Vec3<t>(x+v.x, y+v.y, z+v.z); }\n    inline Vec3<t> operator -(const Vec3<t> &v) const { return Vec3<t>(x-v.x, y-v.y, z-v.z); }\n    inline Vec3<t> operator *(float f)          const { return Vec3<t>(x*f, y*f, z*f); }\n    inline t       operator *(const Vec3<t> &v) const { return x*v.x + y*v.y + z*v.z; }\n    float norm () const { return std::sqrt(x*x+y*y+z*z); }\n    Vec3<t> & normalize(t l=1) { *this = (*this)*(l/norm()); return *this; }\n    template <class > friend std::ostream& operator<<(std::ostream& s, Vec3<t>& v);\n};\n\ntypedef Vec2<float> Vec2f;\ntypedef Vec2<int>   Vec2i;\ntypedef Vec3<float> Vec3f;\ntypedef Vec3<int>   Vec3i;\n\ntemplate <class t> std::ostream& operator<<(std::ostream& s, Vec2<t>& v) {\n    s << \"(\" << v.x << \", \" << v.y << \")\\n\";\n    return s;\n}\n\ntemplate <class t> std::ostream& operator<<(std::ostream& s, Vec3<t>& v) {\n    s << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\\n\";\n    return s;\n}\n```\n\n\n\n如何画出实心的三角形？一般来说，有扫描线和边界函数两种算法。\n\n对于多线程的CPU,采用边界函数法更为高效：先找到三角形的矩形包围盒，再逐点判断是否在三角形中\n\n```cpp\ntriangle(vec2 points[3]) { \n    vec2 bbox[2] = find_bounding_box(points); \n    for (each pixel in the bounding box) { \n        if (inside(points, pixel)) { \n            put_pixel(pixel); \n        } \n    } \n}\n```\n\n因此，问题变成了给定三角形的三个点，如何判断点是否在三角形内部\n\n一种最好的办法是，计算给定点关于给定三角形的重心坐标（或者叫面积坐标）。\n\n维基百科：https://zh.wikipedia.org/wiki/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87\n\n简单来说，它表示一个点所对的三条边形成的三角形面积比。如果点在三角形外部，则有一个维度是负的。\n\n![image-20240419185822971](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419175823218-1822502417.png)\n\n由于tinyrenderer的作者写得有些丑陋，我在geometry.h里直接加入了polygon和triangle类，来实现重心坐标计算和点在三角形内的检测\n\n```cpp\ntemplate <class T>\nclass Polygon2D {\npublic:\n    int n;\n    std::vector<Vec2<T>> pt;\n    Polygon2D(int _n, std::vector<Vec2<T>> _pt): n(_n), pt(_pt) {}\n};\n\ntemplate <class T>\nclass Triangle2D: public Polygon2D<T> {\npublic:\n    using Polygon2D<T>::pt;\n    Triangle2D(std::vector<Vec2<T>> _pt): Polygon2D<T>(3, _pt) {}\n    Vec3f baryCentric(Vec2i P) {\n        Vec3f u = Vec3f(pt[2][0]-pt[0][0], pt[1][0]-pt[0][0], pt[0][0]-P[0])^Vec3f(pt[2][1]-pt[0][1], pt[1][1]-pt[0][1], pt[0][1]-P[1]);\n        /* `pts` and `P` has integer value as coordinates\n           so `abs(u[2])` < 1 means `u[2]` is 0, that means\n           triangle is degenerate, in this case return something with negative coordinates */\n        if (std::abs(u.z)<1) return Vec3f(-1,1,1);\n        return Vec3f(1.f-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);\n    }\n\n    bool inInside(Vec2i P) {\n        auto bc = baryCentric(P);\n        if (bc.x<0 || bc.y<0 || bc.z<0) return false;\n        return true;\n    }\n};\n```\n\n在main.cpp里绘制实心三角形\n\n```cpp\n//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside\nvoid drawSolidTriangle(Triangle2D<int> tri, TGAImage &image, TGAColor color) {\n    Vec2i bboxmin(image.get_width()-1,  image.get_height()-1);\n    Vec2i bboxmax(0, 0);\n    Vec2i clamp(image.get_width()-1, image.get_height()-1);\n    for (int i=0; i<3; i++) {\n        bboxmin.x = std::max(0, std::min(bboxmin.x, tri.pt[i].x));\n        bboxmin.y = std::max(0, std::min(bboxmin.y, tri.pt[i].y));\n\n        bboxmax.x = std::min(clamp.x, std::max(bboxmax.x, tri.pt[i].x));\n        bboxmax.y = std::min(clamp.y, std::max(bboxmax.y, tri.pt[i].y));\n    }\n    Vec2i P;\n    for (P.x=bboxmin.x; P.x<=bboxmax.x; P.x++) {\n        for (P.y=bboxmin.y; P.y<=bboxmax.y; P.y++) {\n            Vec3f bc_screen  = tri.baryCentric(P);\n            if (bc_screen.x<0 || bc_screen.y<0 || bc_screen.z<0) continue;\n            image.set(P.x, P.y, color);\n        }\n    }\n};\n```\n\n得到如图效果：\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419185714797-2050127591.png\" alt=\"image-20240419195714296\" style=\"zoom:50%;\" />\n\n三角形绘制完成后，可以尝试导入作者提供的由三角形构成的人脸模型。\n\n.obj模型文件的格式如下\n\n```\n# List of geometric vertices, with (x, y, z, [w]) coordinates, w is optional and defaults to 1.0.\nv 0.123 0.234 0.345 1.0\nv ...\n...\n# List of texture coordinates, in (u, [v, w]) coordinates, these will vary between 0 and 1. v, w are optional and default to 0.\nvt 0.500 1 [0]\nvt ...\n...\n# List of vertex normals in (x,y,z) form; normals might not be unit vectors.\nvn 0.707 0.000 0.707\nvn ...\n...\n# Parameter space vertices in (u, [v, w]) form; free form geometry statement (see below)\nvp 0.310000 3.210000 2.100000\nvp ...\n...\n# Polygonal face element (see below)\nf 1 2 3\nf 3/1 4/2 5/3\nf 6/4/1 3/5/3 7/6/5\nf 7//1 8//2 9//3\nf ...\n...\n# Line element (see below)\nl 5 8 1 2 4 9\n```\n\n目前，我们暂时不关心模型的深度（z坐标），只是将模型正投影到XY平面上，则模型上的点对应的屏幕坐标可以这样简单的计算\n\n```cpp\nscreen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n```\n\n假设光从正前方射向正后方，即光线方向(0,0,-1)。\n\n在这里，我们使用一种简化的亮度计算方法：我们忽略面与光源之间的距离差异，认为正对着光源的面（法线与光线方向相同）最亮，这样就可以计算每个三角形面的单位法向量与光线方向的叉积来代表亮度。\n\n```cpp\nint main(int argc, char** argv) {\n    if (2==argc) {\n        model = new Model(argv[1]);\n    } else {\n        model = new Model(\"obj/african_head.obj\");\n    }\n\n    TGAImage image(width, height, TGAImage::RGB);\n    Vec3f light_dir(0,0,-1);\n    int cnt = 0;\n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec2i screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n            world_coords[j]  = v;\n        }\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            drawSolidTriangle(Triangle2D<int>({screen_coords[0], screen_coords[1], screen_coords[2]}), image, TGAColor(intensity*255, intensity*255, intensity*255, 255));\n        }\n    }\n\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    delete model;\n    return 0;\n}\n```\n\n在这种简化下，得到的渲染结果如下：\n![image-20240419205641217](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419195642124-634629665.png)\n\n可以发现，位于口腔中的三角形遮住了嘴唇。下一节课中，我们将考虑深度测试，正确处理多边形的遮挡关系。\n\n\n\n## Lesson 3: Z Buffer\n\n深度检测算法的基本原理是，引入一个大小为像素数量的Z-Buffer数组，初始化所有像素点深度为负无穷。\n\n在遍历像素点时，比较当前三角形上点的深度是否小于Z-Buffer的数值，如果小于，则更新该像素并更新Z-Buffer。\n\n为此，我们需要为屏幕坐标增加一维深度（对于上面的人脸设置为模型的z即可）。在drawSolidTriangle()中增加对深度缓冲区的判断。\n\n```cpp\n//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside\n// 2024 04 26 2d->3d\nvoid drawSolidTriangle(Triangle2D<float> tri, TGAImage &image, TGAColor color, float *zbuffer) {\n    Vec2f bboxmin(image.get_width()-1,  image.get_height()-1);\n    Vec2f bboxmax(0, 0);\n    Vec2f clamp(image.get_width()-1, image.get_height()-1);\n    for (int i=0; i<3; i++) {\n        bboxmin.x = std::max((float)0, std::min(bboxmin.x, tri.pt[i].x));\n        bboxmin.y = std::max((float)0, std::min(bboxmin.y, tri.pt[i].y));\n\n        bboxmax.x = std::min(clamp.x, std::max(bboxmax.x, tri.pt[i].x));\n        bboxmax.y = std::min(clamp.y, std::max(bboxmax.y, tri.pt[i].y));\n    }\n    Vec3i P;\n    for (P.x=bboxmin.x; P.x<=bboxmax.x; P.x++) {\n        for (P.y=bboxmin.y; P.y<=bboxmax.y; P.y++) {\n            Vec3f bc_screen  = tri.baryCentric(P.toVec2());//toTriangle2D().baryCentric(P);\n            if (bc_screen.x<0 || bc_screen.y<0 || bc_screen.z<0) continue;\n            \n            //bugfix\n            P.z = tri.depth[0] * bc.x + tri.depth[1] * bc.y + tri.depth[2] * bc.z;\n\n            int idx = P.x+P.y*width;\n            if (zbuffer[idx]<P.z) {\n                zbuffer[idx] = P.z;\n                image.set(P.x, P.y, color);\n            }\n        }\n    }\n};\n\n\n\n\nVec3f worldToScreen(Vec3f v) {\n    return Vec3f(int((v.x+1.)*width/2.+.5), int((v.y+1.)*height/2.+.5), v.z);\n}\n\nint main(int argc, char** argv) {\n    if (2==argc) {\n        model = new Model(argv[1]);\n    } else {\n        model = new Model(\"obj/african_head.obj\");\n    }\n\n    float *zbuffer = new float[width * height];\n    for (int i=width*height; i--; zbuffer[i] = -std::numeric_limits<float>::max());\n\n\n    TGAImage image(width, height, TGAImage::RGB);\n    Vec3f light_dir(0,0,-1);\n    int cnt = 0;\n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec3f screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            //screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n            world_coords[j]  = v;\n            screen_coords[j] = worldToScreen(v);\n        }\n\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            drawSolidTriangle(Triangle2D<float>({screen_coords[0], screen_coords[1], screen_coords[2]}), image, TGAColor(intensity*255, intensity*255, intensity*255, 255), zbuffer);\n        }\n    }\n\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    delete model;\n    return 0;\n}\n```\n\n同时，在Triangle2D类中加入depth数组即可\n\n```cpp\ntemplate <class T>\nclass Triangle2D: public Polygon2D<T> {\npublic:\n    using Polygon2D<T>::pt;\n    std::vector<T> depth;\n    \n    Triangle2D(std::vector<Vec2<T>> _pt, std::vector<Vec2<T>> _depth = {0, 0, 0}): \n        Polygon2D<T>(3, _pt), \n        depth(_depth) {}\n        \n    Triangle2D(std::vector<Vec3<float>> _pt):\n        Polygon2D<T>(3, {_pt[0].toVec2(), _pt[1].toVec2(), _pt[2].toVec2()}),\n        depth({_pt[0].z, _pt[1].z, _pt[2].z}) {}\n        \n    Vec3f baryCentric(Vec2f P) {\n        Vec3f u = Vec3f(pt[2][0]-pt[0][0], pt[1][0]-pt[0][0], pt[0][0]-P[0])^Vec3f(pt[2][1]-pt[0][1], pt[1][1]-pt[0][1], pt[0][1]-P[1]);\n        /* `pts` and `P` has integer value as coordinates\n           so `abs(u[2])` < 1 means `u[2]` is 0, that means\n           triangle is degenerate, in this case return something with negative coordinates */\n        if (std::abs(u.z)<1) return Vec3f(-1,1,1);\n        return Vec3f(1.f-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);\n    }\n\n    bool inInside(Vec2i P) {\n        auto bc = baryCentric(P);\n        if (bc.x<0 || bc.y<0 || bc.z<0) return false;\n        return true;\n    }\n};\n\n\n\n```\n\n效果如图所示：\n![image-20240426175739547](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426165741120-55012551.png)\n\n### Bouns: Texture Mapping\n\n在.obj文件中，有以“vt u v”开头的行，它们给出了一个纹理坐标数组。 \n\n> The number in the middle (between the slashes) in the facet lines \"f x/x/x x/x/x x/x/x\" are the texture coordinates of this vertex of this triangle. Interpolate it inside the triangle, multiply by the width-height of the texture image and you will get the color to put in your render.\n\ntinyrender作者提供了漫反射纹理： [african_head_diffuse.tga](..\\Downloads\\african_head_diffuse.tga) \n\n据此，我们可以给上述人脸模型添加纹理。此时，main函数中drawSolidTriangle函数里不需要再传入颜色，只需要传入intensity即可，另外需要传入当前三角形三个点的纹理坐标uv。\n\n```cpp\n//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside\n// 2024 04 26 2d->3d, texture mapping\nvoid drawSolidTriangle(Triangle2D<float> tri, Vec2i* uv, TGAImage &image, float intensity, float *zbuffer) {\n    Vec2f bboxmin(image.get_width()-1,  image.get_height()-1);\n    Vec2f bboxmax(0, 0);\n    Vec2f clamp(image.get_width()-1, image.get_height()-1);\n    for (int i=0; i<3; i++) {\n        bboxmin.x = std::max((float)0, std::min(bboxmin.x, tri.pt[i].x));\n        bboxmin.y = std::max((float)0, std::min(bboxmin.y, tri.pt[i].y));\n\n        bboxmax.x = std::min(clamp.x, std::max(bboxmax.x, tri.pt[i].x));\n        bboxmax.y = std::min(clamp.y, std::max(bboxmax.y, tri.pt[i].y));\n    }\n    Vec3i P;\n    for (P.x=bboxmin.x; P.x<=bboxmax.x; P.x++) {\n        for (P.y=bboxmin.y; P.y<=bboxmax.y; P.y++) {\n            Vec3f bc  = tri.baryCentric(P.toVec2());//toTriangle2D().baryCentric(P);\n            if (bc.x<0 || bc.y<0 || bc.z<0) continue;\n            \n            P.z = tri.depth[0] * bc.x + tri.depth[1] * bc.y + tri.depth[2] * bc.z;\n\n            int idx = P.x+P.y*width;\n            if (zbuffer[idx]<P.z) {\n                zbuffer[idx] = P.z;\n\n                Vec2i P_uv = uv[0] * bc.x + uv[1] * bc.y + uv[2] * bc.z;\n                TGAColor color = model->diffuse(P_uv);\n                image.set(P.x, P.y, color);\n            }\n        }\n    }\n};\n\n\n\n\nVec3f worldToScreen(Vec3f v) {\n    return Vec3f(int((v.x+1.)*width/2.+.5), int((v.y+1.)*height/2.+.5), v.z);\n}\n\nint main(int argc, char** argv) {\n    if (2==argc) {\n        model = new Model(argv[1]);\n    } else {\n        model = new Model(\"obj/african_head.obj\");\n    }\n\n    float *zbuffer = new float[width * height];\n    for (int i=width*height; i--; zbuffer[i] = -std::numeric_limits<float>::max());\n\n\n    TGAImage image(width, height, TGAImage::RGB);\n    Vec3f light_dir(0,0,-1);\n    int cnt = 0;\n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec3f screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            //screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n            world_coords[j]  = v;\n            screen_coords[j] = worldToScreen(v);\n        }\n\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            Vec2i uv[3];\n            for (int j = 0; j < 3; j++) uv[j] = model->uv(i, j);\n            drawSolidTriangle(Triangle2D<float>({screen_coords[0], screen_coords[1], screen_coords[2]}), uv, image, intensity, zbuffer);\n        }\n    }\n\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    delete model;\n    return 0;\n}\n```\n\nmodel.h和model.cpp需要修改以支持纹理。作者在lesson4的结尾放出了代码。\n\n效果：\n\n\n\n![image-20240426190246539](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426180250012-1899969424.png)\n\n这是一个平行投影的结果，损失了一部分真实感，例如，虽然耳朵旁边的头发在xoy平面上不与脸部重叠，但实际上应该被前边的皮肤遮挡，因为人眼/相机本身是“点光源”，而不是“平行光源”，物体发出的光线最终汇聚于一点，也就是所谓的“透视”。下面将引入透视投影：\n\n\n\n## Lesson 4: Perspective projection\n\n\n\n\n\n\n\n\n\n齐次坐标\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f10.png)\n\n\n\n\n\n简单变换（图来自GAMES101）\n\n![image-20240505174927834](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505164930200-682100308.png)\n\n逆变换\n\n![image-20240505175454080](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165458526-1584226714.png)\n\n复合变换\n\n![image-20240505175019922](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165021790-531013206.png)\n\n\n\n\n\n\n\n实现矩阵类：\n\n```cpp\nconst int DEFAULT_D = 4;\nclass Matrix {\n    std::vector<std::vector<float>> m;\n    int nrow, ncol;\npublic:\n    Matrix(int r=DEFAULT_D, int c=DEFAULT_D) :\n        m(std::vector<std::vector<float>> (r, std::vector<float>(c, 0.f))),\n        nrow(r), ncol(c) {}\n\n    int get_nrow() { return nrow; }\n    int get_ncol() { return ncol; }\n\n    static Matrix identity(int dimensions) {\n        Matrix E(dimensions, dimensions);\n        for (int i = 0; i < dimensions; i++)\n            E[i][i] = 1;\n        return E;\n    }\n\n    std::vector<float>& operator[](const int i) {\n        assert(i >= 0 && i < nrow);\n        return m[i];\n    }\n\n    const std::vector<float>& operator[](const int i) const {\n        assert(i >= 0 && i < nrow);\n        return m[i];\n    }\n\n    Matrix operator*(const Matrix& a) {\n        assert(this->ncol == a.nrow);\n        Matrix res(this->nrow, a.ncol);\n        for (int i = 0; i < this->nrow; i++) {\n            for (int j = 0; j < a.ncol; j++) {\n                res.m[i][j] = 0;\n                for (int k = 0; k < this->ncol; k++)\n                    res.m[i][j] += this->m[i][k]*a.m[k][j];\n            }\n        }\n        return res;\n    }\n\n    Matrix transpose() {\n        Matrix res(ncol, nrow);\n        for (int i = 0; i < ncol; i++)\n            for (int j = 0; j < nrow; j++)\n                res.m[i][j] = m[j][i];\n        return res;\n    }\n    Matrix inverse() {\n        assert(nrow==ncol);\n        // augmenting the square matrix with the identity matrix of the same dimensions a => [ai]\n        Matrix result(nrow, ncol*2);\n        for(int i=0; i<nrow; i++)\n            for(int j=0; j<ncol; j++)\n                result[i][j] = m[i][j];\n        for(int i=0; i<nrow; i++)\n            result[i][i+ncol] = 1;\n        // first pass\n        for (int i=0; i<nrow-1; i++) {\n            // normalize the first row\n            for(int j=result.ncol-1; j>=0; j--)\n                result[i][j] /= result[i][i];\n            for (int k=i+1; k<nrow; k++) {\n                float coeff = result[k][i];\n                for (int j=0; j<result.ncol; j++) {\n                    result[k][j] -= result[i][j]*coeff;\n                }\n            }\n        }\n        // normalize the last row\n        for(int j=result.ncol-1; j>=nrow-1; j--)\n            result[nrow-1][j] /= result[nrow-1][nrow-1];\n        // second pass\n        for (int i=nrow-1; i>0; i--) {\n            for (int k=i-1; k>=0; k--) {\n                float coeff = result[k][i];\n                for (int j=0; j<result.ncol; j++) {\n                    result[k][j] -= result[i][j]*coeff;\n                }\n            }\n        }\n        // cut the identity matrix back\n        Matrix truncate(nrow, ncol);\n        for(int i=0; i<nrow; i++)\n            for(int j=0; j<ncol; j++)\n                truncate[i][j] = result[i][j+ncol];\n        return truncate;\n    }\n\n    friend std::ostream& operator<<(std::ostream& s, Matrix& m);\n};\n\ninline std::ostream& operator<<(std::ostream& s, Matrix& m) {\n    for (int i = 0; i < m.nrow; i++)  {\n        for (int j = 0; j < m.ncol; j++) {\n            s << m[i][j];\n            if (j<m.ncol-1) s << \"\\t\";\n        }\n        s << \"\\n\";\n    }\n    return s;\n}\n```\n\n\n\n一个简单投影矩阵的推导：\n\n假设相机位置为（0,0,c）成像平面为z=0，如图\n\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/525d3930435c3be900e4c7956edb5a1c.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n\n\n根据三角形相似，x'/c = x/(c-z)，即有\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f15.png)\n\n同理\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f16.png)\n\n为了实现z轴方向上靠近相机的线段被拉伸，远离相机的线段被压缩，投影矩阵具有这样的形式\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f13.png)\n\n根据齐次坐标的结果，得到对应的投影点坐标\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f14.png)\n\n根据上面的结果，可知r=-1/c。\n\n我们可以得到一个简单情况下的投影矩阵，变换过程如图\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f17.png)\n\n\n\n\n\n在程序中，这个过程用如下方式实现：\n\n```cpp\nscreen_coords[j] = hc2v(viewportMatrix * projectionMatrix * v2hc(v));\n```\n\n(普通坐标 → 齐次坐标)\n\n世界坐标 → (经投影变换)投影坐标 → （经视口变换)屏幕坐标 \n\n(齐次坐标 → 普通坐标)\n\n这里的坐标包含位置(x,y)和深度z,深度交给z-buffer来处理\n\n视口变化的目的是将投影区域映射到[-1,1]^3的立方体中，便于绘制\n\n相关变化的实现：\n\n```cpp\n//Transition between coordinates (vector type) and homogeneous coordinates (matrix type)\nMatrix v2hc(const Vec3f &v) {\n    Matrix hc(4, 1);\n    hc[0][0] = v.x;\n    hc[1][0] = v.y;\n    hc[2][0] = v.z;\n    hc[3][0] = 1;\n    return hc;\n}\nVec3f hc2v(const Matrix &hc) {\n    return Vec3f(hc[0][0], hc[1][0], hc[2][0]) * (1.f / hc[3][0]);\n}\n\nVec3f light_dir(0,0,-1);\nVec3f camera(0, 0, 3);\n//project to z = 0\nMatrix projection(const Vec3f &camera) {\n    Matrix m = Matrix::identity(4);\n    m[3][2] = -1.f/camera.z;\n    return m;\n}\n\n//viewport(width / 8, height / 8, width * 0.75, height * 0.75);\n//窗口边缘留出1/8空隙\nMatrix viewport(int x, int y, int w, int h) {\n    Matrix m = Matrix::identity(4);\n    //Translation\n    m[0][3] = x + w / 2.f;\n    m[1][3] = y + h / 2.f;\n    m[2][3] = depth / 2.f;\n    //scale to [0, 1]\n    m[0][0] = w / 2.f;\n    m[1][1] = h / 2.f;\n    m[2][2] = depth / 2.f;\n    return m;\n}\n\nint main() {\n\t...\n\n    Matrix projectionMatrix = projection(camera);\n    Matrix viewportMatrix = viewport(width / 8, height / 8, width * 0.75, height * 0.75);\n\n    ...\n        \n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec3f screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            //world -> screen:\n            //3d coordinate -> homogeneous coordinates\n            //-> projection trans(camera at (0,0,c), project to plane z = 0)\n            //-> viewport trans(to make central at (w/2,h/2,d/2))\n\n            world_coords[j]  = v;\n            screen_coords[j] = hc2v(viewportMatrix * projectionMatrix * v2hc(v));\n        }\n\n        //Still simplified light intensity\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            Vec2i uv[3];\n            for (int j = 0; j < 3; j++) uv[j] = model->uv(i, j);\n            drawSolidTriangle(Triangle2D<float>({screen_coords[0], screen_coords[1], screen_coords[2]}), uv, image, intensity, zbuffer);\n        }\n    }\n    ...\n}\n```\n\n\n\n\n\n效果\n\n![image-20240504170937200](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240504160940105-1636523864.png)\n\n\n\n\n\n注：TinyRenderer的透视投影与GAMES101处理方式不同，GAMES101是把M\\[3\\]\\[2\\]固定为1，求解M的第三行，而此处是固定第三行为（0 0 1 0），求解M\\[3\\]\\[2\\]。\n\n此处并没有“近平面”的概念，认为n=0,f=c。\n\n下面是GAMES101给出的结果（第三行为0 0 A B）：\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182227248-1392365094.png\" alt=\"image-20240505192224927\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182300021-22198105.png\" alt=\"image-20240505192257807\" style=\"zoom:50%;\" />\n\n\n\n## Lesson 5: Moving the camera\n\n之前，我们考虑了相机在(0,0,c)，朝着-z方向看的情况。\n\n对于任意的相机位置，需要三个向量来确定：相机坐标e，相机指向的点c，向上方向向量u,如图所示：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/b94dd4a591514fd66a91a6e4cc065644.png)\n\n我们假定相机总是朝着-z方向看，而u朝向正y方向，据此就得到了一个新的坐标系x'y'z'，\n\n下面考虑如何将物体坐标[x,y,z]转化为新坐标系下的[x',y',z']。\n\n\n\n\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f66a0139058ab1d1025dbfd8cd401389.png)\n\n首先回顾坐标[x,y,z]的定义，它是三个正交的单位向量i,j,k前面的系数\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f00.png)\n\n现在，我们有了新的单位向量i',j',k',那么一定存在矩阵M，使得\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f01.png)\n\n我们将OP写成OO'+O'P,与新的单位坐标建立联系：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f02.png)\n\n将[i',j',k']用上面的式子表示，提出[i,j,k]:\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f03.png)\n\n左边用[x,y,z]的定义式替换，就得到了[x',y',z']与[x,y,z]的关系\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f04.png)\n\n\n\n\n\n\n\n关于look at的推导，此处写的有些混乱\n建议参阅https://www.zhihu.com/question/447781866 \n\n下面是个人理解：\n\n简单来说，设M是(0, 0, 0),[i,j,k]到eyepos, [i',j',k']的变换矩阵\n则M=TR,先旋转后平移\n\n其中旋转矩阵R根据单位向量**左乘**该矩阵得到新单位向量，很容易得到(此处r,u,v是i',j',k'在原坐标系下的坐标)\n\n![image-20240505220527743](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505210530096-395261047.png)\n\n而T则为原点平移到eye pos的平移矩阵 （C是eyepos)\n\n![image-20240505221319762](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505211321938-1985120681.png)\n\n此为对坐标轴的变换矩阵，即，我们用M计算了**新的单位向量在原坐标系下的坐标**，而要得到原来单位向量在新坐标系下的坐标，显然应该左乘M的逆矩阵。这样，我们就求得了ModelView矩阵。\n\n\n\n据此，编写lookup实现modelview的计算\n\n```cpp\nVec3f light_dir = Vec3f(0, 0, -1).normalize();\nVec3f eye(1, 1, 3);\nVec3f center(0, 0, 0);\nVec3f up(0, 1, 0);\n//Vec3f camera(0, 0, 3);\n\n//screen_coordinate = viewport * projection * modelview * world_coordinate\nMatrix lookat(Vec3f eye, Vec3f center, Vec3f up) {\n    Vec3f z = (eye - center).normalize();\n    Vec3f x = (up ^ z).normalize();\n    Vec3f y = (z ^ x).normalize();\n    Matrix M_inv = Matrix::identity(4);\n    Matrix T = Matrix::identity(4);\n    //thanks https://www.zhihu.com/question/447781866\n    for (int i = 0; i < 3; i++) {\n        M_inv[0][i] = x[i];\n        M_inv[1][i] = y[i];\n        M_inv[2][i] = z[i];\n        T[i][3] = -eye[i];\n    }\n    return M_inv * T;\n}\n\n\nMatrix projection(Vec3f eye, Vec3f center) {\n    Matrix m = Matrix::identity(4);\n    m[3][2] = -1.f / (eye - center).norm();\n    //m[3][2] = -1.f / camera.z;\n    return m;\n}\n\n\nint main() {\n    ...\n        \n    Matrix modelviewMatrix = lookat(eye, center, up);\n    Matrix projectionMatrix = projection(eye, center);\n    Matrix viewportMatrix = viewport(width / 8, height / 8, width * 0.75, height * 0.75);\n\n    ...\n    screen_coords[j] = hc2v(viewportMatrix * projectionMatrix * modelviewMatrix * v2hc(v));\n    ...\n    \n}\n```\n\n效果 目前有点bug\n\n![image-20240505225818988](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505215822020-1676545529.png)\n\n\n\n\n\n\n### Bouns：Transformation of normal vectors\n\n为了处理光照，我们将模型进行坐标变换后，如果模型提供了每个面的法向量，还需要将法向量也进行变换。\n\n此处有一个结论：模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置。\n\n证明：考虑平面方程 Ax+By+Cz=0，它的法向量是（A,B,C) ,写成矩阵形式为：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f05.png)\n\n在两者之间插入M的逆和M：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f06.png)\n\n 由于坐标均为列向量，把左边写成转置形式：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f07.png)\n\n因此，如果对坐标(x,y,z)做变换M，要满足原来的直线方程，对法向量的变换矩阵为M的逆矩阵的转置（或者转置再求逆，转置和求逆是**可交换的**，证明略）\n\n## Lesson 6: Shaders \n\n本节主要分为两大部分：重构代码，实现不同的shaders。\n\n再尝试用自己之前的屎山适配Shader部分后，我放弃了，直接使用作者写的geometry。内容大部分都很直观，值得注意的是\n\n```cpp\ntemplate<size_t LEN,size_t DIM,typename T> vec<LEN,T> embed(const vec<DIM,T> &v, T fill=1) {\n    vec<LEN,T> ret;\n    for (size_t i=LEN; i--; ret[i]=(i<DIM?v[i]:fill));\n    return ret;\n}\n\ntemplate<size_t LEN,size_t DIM, typename T> vec<LEN,T> proj(const vec<DIM,T> &v) {\n    vec<LEN,T> ret;\n    for (size_t i=LEN; i--; ret[i]=v[i]);\n    return ret;\n}\n```\n\n这两个模板的作用，分别是将低维向量拓展到高维（不足补1）、高维向量投影到低维（截取前LEN个坐标），在涉及其次坐标和普通坐标的转换时多次用到。\n\n\n\n\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/OpenGL-2.0-Programmable-Shader-Pipeline.png)\n\n\n\nShader包含顶点着色和片元着色两个部件，将其抽离出来，可以使得我们通过修改Shader即可实现各种不同的渲染效果，而无需改动其他代码。\n\n在`gl.h`中，定义Shader的基本结构。不同Shader的通过继承基类重写两个虚函数来实现\n\n```cpp\nstruct IShader {\n    virtual ~IShader() {}\n    virtual Vec4f  vertex(int iface, int nthvert) = 0;\n    virtual bool fragment(Vec3f bar, TGAColor &color) = 0;\n};\n```\n\n其中，iface是面的编号，而nthvert是顶点编号（对于三角形为0,1,2）。\n\n例如，一个简单的GouraudShader，vertex通过顶点法向量与光照的点乘计算三角形每个顶点的光照，而fragment通过重心坐标插值计算三角形区域中所有像素的颜色。\n\n```cpp\nstruct GouraudShader : public IShader {\n    Vec3f varying_intensity;\n    //顶点着色\n    virtual Vec4f vertex(int iface, int nthvert) {\n        Vec4f glVertex = embed<4>(model->vert(iface, nthvert));\n        glVertex = Viewport * Projection * ModelView * glVertex;\n        //\n        varying_intensity[nthvert] = std::max(0.f, model->normal(iface, nthvert) * light_dir);\n        return glVertex;\n    }\n    //片段着色 用于drawTriangle \n    //这里的bar即baryCentric\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        float intensity = varying_intensity * bar;\n        color = TGAColor(255, 255, 255) * intensity;\n        return false;\t//返回值表示是否丢弃\n    }\n};\n\n//in main for every vertex\nGouraudShader shader;\nfor (int i=0; i<model->nfaces(); i++) {\n    std::vector<int> face = model->face(i);\n    Vec3f world_coords[3];\n    Vec4f screen_coords[3];\n    for (int j = 0; j < 3; j++) {\n        Vec3f v = model->vert(face[j]);\n        world_coords[j] = v;\n        screen_coords[j] = shader.vertex(i, j);\n    }\n    drawTriangle(screen_coords, shader, image, zbuffer);\n}\n// in drawTriangle, for every pixel\n...\nTGAColor color;\nbool discard = shader.fragment(bc, color);\nif (!discard) {\n    zbuffer.set(P.x, P.y, TGAColor(frag_depth));\n    image.set(P.x, P.y, color);\n}    \n...\n```\n\n所得的效果如图\n\n![image-20240512211917138](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512201920094-1588430460.png)\n\n我们可以轻松地修改着色器，实现不同的渲染效果，如将颜色设置为6个梯度的橙色：\n\n```cpp\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        float intensity = varying_intensity*bar;\n        if (intensity>.85) intensity = 1;\n        else if (intensity>.60) intensity = .80;\n        else if (intensity>.45) intensity = .60;\n        else if (intensity>.30) intensity = .45;\n        else if (intensity>.15) intensity = .30;\n        else intensity = 0;\n        color = TGAColor(255, 155, 0)*intensity;\n        return false;\n    }\n```\n\n效果：\n\n![image-20240512212544885](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202546531-812190877.png)\n\n**纹理着色器**\n\n接下来，我们可以实现漫反射纹理。只需要修改Shader添加纹理映射项即可。\n\n```cpp\nstruct TextureShader : public IShader {\n    Vec3f          varying_intensity; // written by vertex shader, read by fragment shader\n    mat<2,3,float> varying_uv;        // same as above\n\n    virtual Vec4f vertex(int iface, int nthvert) {\n        varying_uv.set_col(nthvert, model->uv(iface, nthvert));\n        varying_intensity[nthvert] = std::max(0.f, model->normal(iface, nthvert)*light_dir); // get diffuse lighting intensity\n        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert)); // read the vertex from .obj file\n        return Viewport*Projection*ModelView*gl_Vertex; // transform it to screen coordinates\n    }\n\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        float intensity = varying_intensity*bar;   // interpolate intensity for the current pixel\n        Vec2f uv = varying_uv*bar;                 // interpolate uv for the current pixel\n        color = model->diffuse(uv)*intensity;      // well duh\n        return false;                              // no, we do not discard this pixel\n    }\n};\n```\n\n效果\n\n![image-20240512212807641](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202811146-1791754725.png)\n\n**法线着色器**\n\n事实上，纹理图像中不止可以储存颜色，还可以储存法线方向、温度等等信息。通过纹理给出每个点的法线方向，就能实现表明的凹凸起伏效果。此时，纹理图像的RGB值不再储存颜色，而是用于储存法线，如下图。\n\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/african_head_nm.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n上节课的结尾，我们提到了“模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置”这一结论，根据这个结论，就可以直接在顶点着色器中分别计算顶点和法向量经过投影后的结构\n\n```cpp\nstruct NormalShader : public IShader {\n    mat<2,3,float> varying_uv;  // same as above\n    mat<4,4,float> uniform_M;   //  Projection*ModelView\n    mat<4,4,float> uniform_MIT; // (Projection*ModelView).invert_transpose()\n\n    virtual Vec4f vertex(int iface, int nthvert) {\n        varying_uv.set_col(nthvert, model->uv(iface, nthvert));\n        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert)); // read the vertex from .obj file\n        return Viewport*Projection*ModelView*gl_Vertex; // transform it to screen coordinates\n   }\n\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        Vec2f uv = varying_uv*bar;                 // interpolate uv for the current pixel\n        Vec3f n = proj<3>(uniform_MIT*embed<4>(model->normal(uv))).normalize();\n        Vec3f l = proj<3>(uniform_M  *embed<4>(light_dir        )).normalize();\n        float intensity = std::max(0.f, n*l);\n        color = model->diffuse(uv)*intensity;      // well duh\n        return false;                              // no, we do not discard this pixel\n    }\n};\n```\n\n效果：\n\n![image-20240512214259167](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512204303617-1448246807.png)\n\n\n\n**Phone模型着色器**\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/e3720a5dfedc49edb0bf70f8bc64204a.png)\n\n根据Phone光照模型，物体的真实光照可以近似为环境光+漫反射+高光。据此，我们可以进一步得出更加真实的着色器。\n\n高光的计算如图所示：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/d58cd3bbab46463e87b782a12a147fbb.png)\n\n已知物体表明法向量为n，入射光为l，两者夹角为a，假设所有向量都被归一化，设反射光为r，则有l+r=2n cosa ，可求得反射光r=2n cosa - l = 2n(n·l)-l。反射光\n\n```cpp\nstruct PhoneShader : public IShader {\n    mat<2,3,float> varying_uv;  // same as above\n    mat<4,4,float> uniform_M;   //  Projection*ModelView\n    mat<4,4,float> uniform_MIT; // (Projection*ModelView).invert_transpose()\n\n    virtual Vec4f vertex(int iface, int nthvert) {\n        varying_uv.set_col(nthvert, model->uv(iface, nthvert));\n        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert)); // read the vertex from .obj file\n        return Viewport*Projection*ModelView*gl_Vertex; // transform it to screen coordinates\n    }\n\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        Vec2f uv = varying_uv*bar;\n        Vec3f n = proj<3>(uniform_MIT*embed<4>(model->normal(uv))).normalize();\n        Vec3f l = proj<3>(uniform_M  *embed<4>(light_dir        )).normalize();\n        Vec3f r = (n*(n*l*2.f) - l).normalize();   // reflected light\n        float spec = pow(std::max(r.z, 0.0f), model->specular(uv));\n        float diff = std::max(0.f, n*l);\n        TGAColor c = model->diffuse(uv);\n        color = c;\n        for (int i=0; i<3; i++) color[i] = std::min<float>(5 + c[i]*(diff + .6*spec), 255);\n        return false;\n    }\n};\n```\n\n按照环境光5+自身颜色*(1漫反射+0.6高光)，得到的效果如下\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512210513789-778169408.png\" alt=\"image-20240512220509696\" style=\"zoom:67%;\" />\n\n我们可以试试其他的配比系数，如`10 + c[i]*(2 * diff + 1.5*spec`\n\n![image-20240512221918507](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211926468-1109783721.png)\n\n另外，我们还可以到master分支找其他的模型，尝试渲染效果\n\n![image-20240512221509093](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211511558-935691911.png)\n\n\n\n![image-20240512222416047](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512212417887-506051993.png)","source":"_posts/TinyRendererNotes.md","raw":"---\ntitle: TinyRendererNotes\ndate: 2024-05-06 00:41:25\ntags: 图形学\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n\n## TinyRender学习笔记\n\n通过手写软光栅渲染器加深对计算机图形学基本原理的理解，并练习C++面向对象程序设计。\n\n该项目主要参考[Home · ssloy/tinyrenderer Wiki (github.com)](https://github.com/ssloy/tinyrenderer/wiki)编写，使用CMake构建\n\n可以浏览我的历史commit，找到不同进度时提交的代码。\n\n本项目涉及的几乎所有的图形学知识都在GAMES101课程中出现过，推荐将GAMES101作为前置课程，或配合GAMES101的进度一起学习。\n\n## Lesson 0 Getting Started\n\n### Using TGA image format\n\n使用这个基本框架来生成TGA格式图像：\n[ssloy/tinyrenderer at 909fe20934ba5334144d2c748805690a1fa4c89f (github.com)](https://github.com/ssloy/tinyrenderer/tree/909fe20934ba5334144d2c748805690a1fa4c89f)\n\n只需 `#include \"tgaimage.h\"` ，并在编译时链接tgaimage.cpp即可。\n\n例：在屏幕上将像素(52,41)设置为红色\n\n```cpp\n#include \"tgaimage.h\"\n//Set color with RGB\nconst TGAColor white = TGAColor(255, 255, 255, 255);\nconst TGAColor red   = TGAColor(255, 0,   0,   255);\nint main(int argc, char** argv) {\n    \t//Set image size\n        TGAImage image(100, 100, TGAImage::RGB);\n    \t//Set pixel color\n        image.set(52, 41, red);\n        //To have the origin at the left bottom corner of the image\n        image.flip_vertically(); \n        image.write_tga_file(\"output.tga\");\n        return 0;\n}\n```\n\n个人推荐的环境：Clion + CMake。（因为VsCode CMake调试功能实在搞不懂=.=)\n\n涉及导入模型，需要将工作目录设置为工程文件夹\n\n![image-20240505230016266](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220018544-333214793.png)\n\n![image-20240505230043985](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220047826-450326712.png)\n\n但我的Clion存在tga图像无法加载的bug。在设置->编辑器->文件类型中去掉.tga，然后选择用本地程序打开即可。\n\n## Lesson 1 Bresenham’s Line Drawing Algorithm\n\n使用Bresenham算法绘制线段。\n\n原理：https://en.wikipedia.org/wiki/Bresenham's_line_algorithm\n\n实现参考：https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C++\n\n建议绘制斜率小于-1，-1到0,0到1,大于1，以及水平和垂直的直线来检验算法正确性。\n\n```cpp\n#include <cmath>\n\n#include \"tgaimage.h\"\n\nconst TGAColor white = TGAColor(255, 255, 255, 255);\nconst TGAColor red = TGAColor(255, 0, 0, 255);\nconst TGAColor blue = TGAColor(0, 0, 255, 255);\n\nvoid line(int x1, int y1, int x2, int y2, TGAImage& image, TGAColor color)\n{\n    //Ensure that slope in (0, 1)\n    const bool steep = (std::abs(y2 - y1) > std::abs(x2 - x1));\n    if (steep) {\n        std::swap(x1, y1);\n        std::swap(x2, y2);\n    }\n    if (x1 > x2) {\n        std::swap(x1, x2);\n        std::swap(y1, y2);\n    }\n\n    const float dx = x2 - x1;\n    const float dy = fabs(y2 - y1);\n\n    float error = dx / 2.0f;\n    const int ystep = (y1 < y2) ? 1 : -1;\n    int y = (int)y1;\n\n    const int maxX = (int)x2;\n\n    for (int x = (int)x1; x <= maxX; x++) {\n        if (steep) {\n            image.set(y, x, color);\n        } else {\n            image.set(x, y, color);\n        }\n\n        error -= dy;\n        if (error < 0) {\n            y += ystep;\n            error += dx;\n        }\n    }\n}\n\nint main(int argc, char** argv)\n{\n    TGAImage image(100, 100, TGAImage::RGB);\n    line(13, 20, 80, 40, image, red);\n    line(55, 33, 22, 66, image, blue);\n    line(33, 33, 66, 66, image, white);\n    line(44, 20, 44, 80, image, white);\n    line(20, 44, 80, 44, image, white);\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    return 0;\n}\n\n```\n\n效果\n\n![image-20240419183705501](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419173705372-1981687689.png)\n\n## Lesson 2: Triangle rasterization and back face culling\n\n三维物体模型通常以三角形为基础。为了方便表示点、向量、多边形，写geometry.h。\n\n```cpp\n#pragma once\n\ntemplate <class t> struct Vec2 {\n    union {\n        struct {t u, v;};\n        struct {t x, y;};\n        t raw[2];\n    };\n    Vec2() : u(0), v(0) {}\n    Vec2(t _u, t _v) : u(_u),v(_v) {}\n    inline Vec2<t> operator +(const Vec2<t> &V) const { return Vec2<t>(u+V.u, v+V.v); }\n    inline Vec2<t> operator -(const Vec2<t> &V) const { return Vec2<t>(u-V.u, v-V.v); }\n    inline Vec2<t> operator *(float f)          const { return Vec2<t>(u*f, v*f); }\n    template <class > friend std::ostream& operator<<(std::ostream& s, Vec2<t>& v);\n};\n\ntemplate <class t> struct Vec3 {\n    union {\n        struct {t x, y, z;};\n        struct { t ivert, iuv, inorm; };\n        t raw[3];\n    };\n    Vec3() : x(0), y(0), z(0) {}\n    Vec3(t _x, t _y, t _z) : x(_x),y(_y),z(_z) {}\n    inline Vec3<t> operator ^(const Vec3<t> &v) const { return Vec3<t>(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); }\n    inline Vec3<t> operator +(const Vec3<t> &v) const { return Vec3<t>(x+v.x, y+v.y, z+v.z); }\n    inline Vec3<t> operator -(const Vec3<t> &v) const { return Vec3<t>(x-v.x, y-v.y, z-v.z); }\n    inline Vec3<t> operator *(float f)          const { return Vec3<t>(x*f, y*f, z*f); }\n    inline t       operator *(const Vec3<t> &v) const { return x*v.x + y*v.y + z*v.z; }\n    float norm () const { return std::sqrt(x*x+y*y+z*z); }\n    Vec3<t> & normalize(t l=1) { *this = (*this)*(l/norm()); return *this; }\n    template <class > friend std::ostream& operator<<(std::ostream& s, Vec3<t>& v);\n};\n\ntypedef Vec2<float> Vec2f;\ntypedef Vec2<int>   Vec2i;\ntypedef Vec3<float> Vec3f;\ntypedef Vec3<int>   Vec3i;\n\ntemplate <class t> std::ostream& operator<<(std::ostream& s, Vec2<t>& v) {\n    s << \"(\" << v.x << \", \" << v.y << \")\\n\";\n    return s;\n}\n\ntemplate <class t> std::ostream& operator<<(std::ostream& s, Vec3<t>& v) {\n    s << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\\n\";\n    return s;\n}\n```\n\n\n\n如何画出实心的三角形？一般来说，有扫描线和边界函数两种算法。\n\n对于多线程的CPU,采用边界函数法更为高效：先找到三角形的矩形包围盒，再逐点判断是否在三角形中\n\n```cpp\ntriangle(vec2 points[3]) { \n    vec2 bbox[2] = find_bounding_box(points); \n    for (each pixel in the bounding box) { \n        if (inside(points, pixel)) { \n            put_pixel(pixel); \n        } \n    } \n}\n```\n\n因此，问题变成了给定三角形的三个点，如何判断点是否在三角形内部\n\n一种最好的办法是，计算给定点关于给定三角形的重心坐标（或者叫面积坐标）。\n\n维基百科：https://zh.wikipedia.org/wiki/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87\n\n简单来说，它表示一个点所对的三条边形成的三角形面积比。如果点在三角形外部，则有一个维度是负的。\n\n![image-20240419185822971](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419175823218-1822502417.png)\n\n由于tinyrenderer的作者写得有些丑陋，我在geometry.h里直接加入了polygon和triangle类，来实现重心坐标计算和点在三角形内的检测\n\n```cpp\ntemplate <class T>\nclass Polygon2D {\npublic:\n    int n;\n    std::vector<Vec2<T>> pt;\n    Polygon2D(int _n, std::vector<Vec2<T>> _pt): n(_n), pt(_pt) {}\n};\n\ntemplate <class T>\nclass Triangle2D: public Polygon2D<T> {\npublic:\n    using Polygon2D<T>::pt;\n    Triangle2D(std::vector<Vec2<T>> _pt): Polygon2D<T>(3, _pt) {}\n    Vec3f baryCentric(Vec2i P) {\n        Vec3f u = Vec3f(pt[2][0]-pt[0][0], pt[1][0]-pt[0][0], pt[0][0]-P[0])^Vec3f(pt[2][1]-pt[0][1], pt[1][1]-pt[0][1], pt[0][1]-P[1]);\n        /* `pts` and `P` has integer value as coordinates\n           so `abs(u[2])` < 1 means `u[2]` is 0, that means\n           triangle is degenerate, in this case return something with negative coordinates */\n        if (std::abs(u.z)<1) return Vec3f(-1,1,1);\n        return Vec3f(1.f-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);\n    }\n\n    bool inInside(Vec2i P) {\n        auto bc = baryCentric(P);\n        if (bc.x<0 || bc.y<0 || bc.z<0) return false;\n        return true;\n    }\n};\n```\n\n在main.cpp里绘制实心三角形\n\n```cpp\n//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside\nvoid drawSolidTriangle(Triangle2D<int> tri, TGAImage &image, TGAColor color) {\n    Vec2i bboxmin(image.get_width()-1,  image.get_height()-1);\n    Vec2i bboxmax(0, 0);\n    Vec2i clamp(image.get_width()-1, image.get_height()-1);\n    for (int i=0; i<3; i++) {\n        bboxmin.x = std::max(0, std::min(bboxmin.x, tri.pt[i].x));\n        bboxmin.y = std::max(0, std::min(bboxmin.y, tri.pt[i].y));\n\n        bboxmax.x = std::min(clamp.x, std::max(bboxmax.x, tri.pt[i].x));\n        bboxmax.y = std::min(clamp.y, std::max(bboxmax.y, tri.pt[i].y));\n    }\n    Vec2i P;\n    for (P.x=bboxmin.x; P.x<=bboxmax.x; P.x++) {\n        for (P.y=bboxmin.y; P.y<=bboxmax.y; P.y++) {\n            Vec3f bc_screen  = tri.baryCentric(P);\n            if (bc_screen.x<0 || bc_screen.y<0 || bc_screen.z<0) continue;\n            image.set(P.x, P.y, color);\n        }\n    }\n};\n```\n\n得到如图效果：\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419185714797-2050127591.png\" alt=\"image-20240419195714296\" style=\"zoom:50%;\" />\n\n三角形绘制完成后，可以尝试导入作者提供的由三角形构成的人脸模型。\n\n.obj模型文件的格式如下\n\n```\n# List of geometric vertices, with (x, y, z, [w]) coordinates, w is optional and defaults to 1.0.\nv 0.123 0.234 0.345 1.0\nv ...\n...\n# List of texture coordinates, in (u, [v, w]) coordinates, these will vary between 0 and 1. v, w are optional and default to 0.\nvt 0.500 1 [0]\nvt ...\n...\n# List of vertex normals in (x,y,z) form; normals might not be unit vectors.\nvn 0.707 0.000 0.707\nvn ...\n...\n# Parameter space vertices in (u, [v, w]) form; free form geometry statement (see below)\nvp 0.310000 3.210000 2.100000\nvp ...\n...\n# Polygonal face element (see below)\nf 1 2 3\nf 3/1 4/2 5/3\nf 6/4/1 3/5/3 7/6/5\nf 7//1 8//2 9//3\nf ...\n...\n# Line element (see below)\nl 5 8 1 2 4 9\n```\n\n目前，我们暂时不关心模型的深度（z坐标），只是将模型正投影到XY平面上，则模型上的点对应的屏幕坐标可以这样简单的计算\n\n```cpp\nscreen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n```\n\n假设光从正前方射向正后方，即光线方向(0,0,-1)。\n\n在这里，我们使用一种简化的亮度计算方法：我们忽略面与光源之间的距离差异，认为正对着光源的面（法线与光线方向相同）最亮，这样就可以计算每个三角形面的单位法向量与光线方向的叉积来代表亮度。\n\n```cpp\nint main(int argc, char** argv) {\n    if (2==argc) {\n        model = new Model(argv[1]);\n    } else {\n        model = new Model(\"obj/african_head.obj\");\n    }\n\n    TGAImage image(width, height, TGAImage::RGB);\n    Vec3f light_dir(0,0,-1);\n    int cnt = 0;\n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec2i screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n            world_coords[j]  = v;\n        }\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            drawSolidTriangle(Triangle2D<int>({screen_coords[0], screen_coords[1], screen_coords[2]}), image, TGAColor(intensity*255, intensity*255, intensity*255, 255));\n        }\n    }\n\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    delete model;\n    return 0;\n}\n```\n\n在这种简化下，得到的渲染结果如下：\n![image-20240419205641217](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419195642124-634629665.png)\n\n可以发现，位于口腔中的三角形遮住了嘴唇。下一节课中，我们将考虑深度测试，正确处理多边形的遮挡关系。\n\n\n\n## Lesson 3: Z Buffer\n\n深度检测算法的基本原理是，引入一个大小为像素数量的Z-Buffer数组，初始化所有像素点深度为负无穷。\n\n在遍历像素点时，比较当前三角形上点的深度是否小于Z-Buffer的数值，如果小于，则更新该像素并更新Z-Buffer。\n\n为此，我们需要为屏幕坐标增加一维深度（对于上面的人脸设置为模型的z即可）。在drawSolidTriangle()中增加对深度缓冲区的判断。\n\n```cpp\n//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside\n// 2024 04 26 2d->3d\nvoid drawSolidTriangle(Triangle2D<float> tri, TGAImage &image, TGAColor color, float *zbuffer) {\n    Vec2f bboxmin(image.get_width()-1,  image.get_height()-1);\n    Vec2f bboxmax(0, 0);\n    Vec2f clamp(image.get_width()-1, image.get_height()-1);\n    for (int i=0; i<3; i++) {\n        bboxmin.x = std::max((float)0, std::min(bboxmin.x, tri.pt[i].x));\n        bboxmin.y = std::max((float)0, std::min(bboxmin.y, tri.pt[i].y));\n\n        bboxmax.x = std::min(clamp.x, std::max(bboxmax.x, tri.pt[i].x));\n        bboxmax.y = std::min(clamp.y, std::max(bboxmax.y, tri.pt[i].y));\n    }\n    Vec3i P;\n    for (P.x=bboxmin.x; P.x<=bboxmax.x; P.x++) {\n        for (P.y=bboxmin.y; P.y<=bboxmax.y; P.y++) {\n            Vec3f bc_screen  = tri.baryCentric(P.toVec2());//toTriangle2D().baryCentric(P);\n            if (bc_screen.x<0 || bc_screen.y<0 || bc_screen.z<0) continue;\n            \n            //bugfix\n            P.z = tri.depth[0] * bc.x + tri.depth[1] * bc.y + tri.depth[2] * bc.z;\n\n            int idx = P.x+P.y*width;\n            if (zbuffer[idx]<P.z) {\n                zbuffer[idx] = P.z;\n                image.set(P.x, P.y, color);\n            }\n        }\n    }\n};\n\n\n\n\nVec3f worldToScreen(Vec3f v) {\n    return Vec3f(int((v.x+1.)*width/2.+.5), int((v.y+1.)*height/2.+.5), v.z);\n}\n\nint main(int argc, char** argv) {\n    if (2==argc) {\n        model = new Model(argv[1]);\n    } else {\n        model = new Model(\"obj/african_head.obj\");\n    }\n\n    float *zbuffer = new float[width * height];\n    for (int i=width*height; i--; zbuffer[i] = -std::numeric_limits<float>::max());\n\n\n    TGAImage image(width, height, TGAImage::RGB);\n    Vec3f light_dir(0,0,-1);\n    int cnt = 0;\n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec3f screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            //screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n            world_coords[j]  = v;\n            screen_coords[j] = worldToScreen(v);\n        }\n\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            drawSolidTriangle(Triangle2D<float>({screen_coords[0], screen_coords[1], screen_coords[2]}), image, TGAColor(intensity*255, intensity*255, intensity*255, 255), zbuffer);\n        }\n    }\n\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    delete model;\n    return 0;\n}\n```\n\n同时，在Triangle2D类中加入depth数组即可\n\n```cpp\ntemplate <class T>\nclass Triangle2D: public Polygon2D<T> {\npublic:\n    using Polygon2D<T>::pt;\n    std::vector<T> depth;\n    \n    Triangle2D(std::vector<Vec2<T>> _pt, std::vector<Vec2<T>> _depth = {0, 0, 0}): \n        Polygon2D<T>(3, _pt), \n        depth(_depth) {}\n        \n    Triangle2D(std::vector<Vec3<float>> _pt):\n        Polygon2D<T>(3, {_pt[0].toVec2(), _pt[1].toVec2(), _pt[2].toVec2()}),\n        depth({_pt[0].z, _pt[1].z, _pt[2].z}) {}\n        \n    Vec3f baryCentric(Vec2f P) {\n        Vec3f u = Vec3f(pt[2][0]-pt[0][0], pt[1][0]-pt[0][0], pt[0][0]-P[0])^Vec3f(pt[2][1]-pt[0][1], pt[1][1]-pt[0][1], pt[0][1]-P[1]);\n        /* `pts` and `P` has integer value as coordinates\n           so `abs(u[2])` < 1 means `u[2]` is 0, that means\n           triangle is degenerate, in this case return something with negative coordinates */\n        if (std::abs(u.z)<1) return Vec3f(-1,1,1);\n        return Vec3f(1.f-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);\n    }\n\n    bool inInside(Vec2i P) {\n        auto bc = baryCentric(P);\n        if (bc.x<0 || bc.y<0 || bc.z<0) return false;\n        return true;\n    }\n};\n\n\n\n```\n\n效果如图所示：\n![image-20240426175739547](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426165741120-55012551.png)\n\n### Bouns: Texture Mapping\n\n在.obj文件中，有以“vt u v”开头的行，它们给出了一个纹理坐标数组。 \n\n> The number in the middle (between the slashes) in the facet lines \"f x/x/x x/x/x x/x/x\" are the texture coordinates of this vertex of this triangle. Interpolate it inside the triangle, multiply by the width-height of the texture image and you will get the color to put in your render.\n\ntinyrender作者提供了漫反射纹理： [african_head_diffuse.tga](..\\Downloads\\african_head_diffuse.tga) \n\n据此，我们可以给上述人脸模型添加纹理。此时，main函数中drawSolidTriangle函数里不需要再传入颜色，只需要传入intensity即可，另外需要传入当前三角形三个点的纹理坐标uv。\n\n```cpp\n//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside\n// 2024 04 26 2d->3d, texture mapping\nvoid drawSolidTriangle(Triangle2D<float> tri, Vec2i* uv, TGAImage &image, float intensity, float *zbuffer) {\n    Vec2f bboxmin(image.get_width()-1,  image.get_height()-1);\n    Vec2f bboxmax(0, 0);\n    Vec2f clamp(image.get_width()-1, image.get_height()-1);\n    for (int i=0; i<3; i++) {\n        bboxmin.x = std::max((float)0, std::min(bboxmin.x, tri.pt[i].x));\n        bboxmin.y = std::max((float)0, std::min(bboxmin.y, tri.pt[i].y));\n\n        bboxmax.x = std::min(clamp.x, std::max(bboxmax.x, tri.pt[i].x));\n        bboxmax.y = std::min(clamp.y, std::max(bboxmax.y, tri.pt[i].y));\n    }\n    Vec3i P;\n    for (P.x=bboxmin.x; P.x<=bboxmax.x; P.x++) {\n        for (P.y=bboxmin.y; P.y<=bboxmax.y; P.y++) {\n            Vec3f bc  = tri.baryCentric(P.toVec2());//toTriangle2D().baryCentric(P);\n            if (bc.x<0 || bc.y<0 || bc.z<0) continue;\n            \n            P.z = tri.depth[0] * bc.x + tri.depth[1] * bc.y + tri.depth[2] * bc.z;\n\n            int idx = P.x+P.y*width;\n            if (zbuffer[idx]<P.z) {\n                zbuffer[idx] = P.z;\n\n                Vec2i P_uv = uv[0] * bc.x + uv[1] * bc.y + uv[2] * bc.z;\n                TGAColor color = model->diffuse(P_uv);\n                image.set(P.x, P.y, color);\n            }\n        }\n    }\n};\n\n\n\n\nVec3f worldToScreen(Vec3f v) {\n    return Vec3f(int((v.x+1.)*width/2.+.5), int((v.y+1.)*height/2.+.5), v.z);\n}\n\nint main(int argc, char** argv) {\n    if (2==argc) {\n        model = new Model(argv[1]);\n    } else {\n        model = new Model(\"obj/african_head.obj\");\n    }\n\n    float *zbuffer = new float[width * height];\n    for (int i=width*height; i--; zbuffer[i] = -std::numeric_limits<float>::max());\n\n\n    TGAImage image(width, height, TGAImage::RGB);\n    Vec3f light_dir(0,0,-1);\n    int cnt = 0;\n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec3f screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            //screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);\n            world_coords[j]  = v;\n            screen_coords[j] = worldToScreen(v);\n        }\n\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            Vec2i uv[3];\n            for (int j = 0; j < 3; j++) uv[j] = model->uv(i, j);\n            drawSolidTriangle(Triangle2D<float>({screen_coords[0], screen_coords[1], screen_coords[2]}), uv, image, intensity, zbuffer);\n        }\n    }\n\n    image.flip_vertically();\n    image.write_tga_file(\"output.tga\");\n    delete model;\n    return 0;\n}\n```\n\nmodel.h和model.cpp需要修改以支持纹理。作者在lesson4的结尾放出了代码。\n\n效果：\n\n\n\n![image-20240426190246539](https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426180250012-1899969424.png)\n\n这是一个平行投影的结果，损失了一部分真实感，例如，虽然耳朵旁边的头发在xoy平面上不与脸部重叠，但实际上应该被前边的皮肤遮挡，因为人眼/相机本身是“点光源”，而不是“平行光源”，物体发出的光线最终汇聚于一点，也就是所谓的“透视”。下面将引入透视投影：\n\n\n\n## Lesson 4: Perspective projection\n\n\n\n\n\n\n\n\n\n齐次坐标\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f10.png)\n\n\n\n\n\n简单变换（图来自GAMES101）\n\n![image-20240505174927834](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505164930200-682100308.png)\n\n逆变换\n\n![image-20240505175454080](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165458526-1584226714.png)\n\n复合变换\n\n![image-20240505175019922](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165021790-531013206.png)\n\n\n\n\n\n\n\n实现矩阵类：\n\n```cpp\nconst int DEFAULT_D = 4;\nclass Matrix {\n    std::vector<std::vector<float>> m;\n    int nrow, ncol;\npublic:\n    Matrix(int r=DEFAULT_D, int c=DEFAULT_D) :\n        m(std::vector<std::vector<float>> (r, std::vector<float>(c, 0.f))),\n        nrow(r), ncol(c) {}\n\n    int get_nrow() { return nrow; }\n    int get_ncol() { return ncol; }\n\n    static Matrix identity(int dimensions) {\n        Matrix E(dimensions, dimensions);\n        for (int i = 0; i < dimensions; i++)\n            E[i][i] = 1;\n        return E;\n    }\n\n    std::vector<float>& operator[](const int i) {\n        assert(i >= 0 && i < nrow);\n        return m[i];\n    }\n\n    const std::vector<float>& operator[](const int i) const {\n        assert(i >= 0 && i < nrow);\n        return m[i];\n    }\n\n    Matrix operator*(const Matrix& a) {\n        assert(this->ncol == a.nrow);\n        Matrix res(this->nrow, a.ncol);\n        for (int i = 0; i < this->nrow; i++) {\n            for (int j = 0; j < a.ncol; j++) {\n                res.m[i][j] = 0;\n                for (int k = 0; k < this->ncol; k++)\n                    res.m[i][j] += this->m[i][k]*a.m[k][j];\n            }\n        }\n        return res;\n    }\n\n    Matrix transpose() {\n        Matrix res(ncol, nrow);\n        for (int i = 0; i < ncol; i++)\n            for (int j = 0; j < nrow; j++)\n                res.m[i][j] = m[j][i];\n        return res;\n    }\n    Matrix inverse() {\n        assert(nrow==ncol);\n        // augmenting the square matrix with the identity matrix of the same dimensions a => [ai]\n        Matrix result(nrow, ncol*2);\n        for(int i=0; i<nrow; i++)\n            for(int j=0; j<ncol; j++)\n                result[i][j] = m[i][j];\n        for(int i=0; i<nrow; i++)\n            result[i][i+ncol] = 1;\n        // first pass\n        for (int i=0; i<nrow-1; i++) {\n            // normalize the first row\n            for(int j=result.ncol-1; j>=0; j--)\n                result[i][j] /= result[i][i];\n            for (int k=i+1; k<nrow; k++) {\n                float coeff = result[k][i];\n                for (int j=0; j<result.ncol; j++) {\n                    result[k][j] -= result[i][j]*coeff;\n                }\n            }\n        }\n        // normalize the last row\n        for(int j=result.ncol-1; j>=nrow-1; j--)\n            result[nrow-1][j] /= result[nrow-1][nrow-1];\n        // second pass\n        for (int i=nrow-1; i>0; i--) {\n            for (int k=i-1; k>=0; k--) {\n                float coeff = result[k][i];\n                for (int j=0; j<result.ncol; j++) {\n                    result[k][j] -= result[i][j]*coeff;\n                }\n            }\n        }\n        // cut the identity matrix back\n        Matrix truncate(nrow, ncol);\n        for(int i=0; i<nrow; i++)\n            for(int j=0; j<ncol; j++)\n                truncate[i][j] = result[i][j+ncol];\n        return truncate;\n    }\n\n    friend std::ostream& operator<<(std::ostream& s, Matrix& m);\n};\n\ninline std::ostream& operator<<(std::ostream& s, Matrix& m) {\n    for (int i = 0; i < m.nrow; i++)  {\n        for (int j = 0; j < m.ncol; j++) {\n            s << m[i][j];\n            if (j<m.ncol-1) s << \"\\t\";\n        }\n        s << \"\\n\";\n    }\n    return s;\n}\n```\n\n\n\n一个简单投影矩阵的推导：\n\n假设相机位置为（0,0,c）成像平面为z=0，如图\n\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/525d3930435c3be900e4c7956edb5a1c.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n\n\n根据三角形相似，x'/c = x/(c-z)，即有\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f15.png)\n\n同理\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f16.png)\n\n为了实现z轴方向上靠近相机的线段被拉伸，远离相机的线段被压缩，投影矩阵具有这样的形式\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f13.png)\n\n根据齐次坐标的结果，得到对应的投影点坐标\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f14.png)\n\n根据上面的结果，可知r=-1/c。\n\n我们可以得到一个简单情况下的投影矩阵，变换过程如图\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f17.png)\n\n\n\n\n\n在程序中，这个过程用如下方式实现：\n\n```cpp\nscreen_coords[j] = hc2v(viewportMatrix * projectionMatrix * v2hc(v));\n```\n\n(普通坐标 → 齐次坐标)\n\n世界坐标 → (经投影变换)投影坐标 → （经视口变换)屏幕坐标 \n\n(齐次坐标 → 普通坐标)\n\n这里的坐标包含位置(x,y)和深度z,深度交给z-buffer来处理\n\n视口变化的目的是将投影区域映射到[-1,1]^3的立方体中，便于绘制\n\n相关变化的实现：\n\n```cpp\n//Transition between coordinates (vector type) and homogeneous coordinates (matrix type)\nMatrix v2hc(const Vec3f &v) {\n    Matrix hc(4, 1);\n    hc[0][0] = v.x;\n    hc[1][0] = v.y;\n    hc[2][0] = v.z;\n    hc[3][0] = 1;\n    return hc;\n}\nVec3f hc2v(const Matrix &hc) {\n    return Vec3f(hc[0][0], hc[1][0], hc[2][0]) * (1.f / hc[3][0]);\n}\n\nVec3f light_dir(0,0,-1);\nVec3f camera(0, 0, 3);\n//project to z = 0\nMatrix projection(const Vec3f &camera) {\n    Matrix m = Matrix::identity(4);\n    m[3][2] = -1.f/camera.z;\n    return m;\n}\n\n//viewport(width / 8, height / 8, width * 0.75, height * 0.75);\n//窗口边缘留出1/8空隙\nMatrix viewport(int x, int y, int w, int h) {\n    Matrix m = Matrix::identity(4);\n    //Translation\n    m[0][3] = x + w / 2.f;\n    m[1][3] = y + h / 2.f;\n    m[2][3] = depth / 2.f;\n    //scale to [0, 1]\n    m[0][0] = w / 2.f;\n    m[1][1] = h / 2.f;\n    m[2][2] = depth / 2.f;\n    return m;\n}\n\nint main() {\n\t...\n\n    Matrix projectionMatrix = projection(camera);\n    Matrix viewportMatrix = viewport(width / 8, height / 8, width * 0.75, height * 0.75);\n\n    ...\n        \n    for (int i=0; i<model->nfaces(); i++) {\n        std::vector<int> face = model->face(i);\n        Vec3f screen_coords[3];\n        Vec3f world_coords[3];\n        for (int j=0; j<3; j++) {\n            Vec3f v = model->vert(face[j]);\n            //world -> screen:\n            //3d coordinate -> homogeneous coordinates\n            //-> projection trans(camera at (0,0,c), project to plane z = 0)\n            //-> viewport trans(to make central at (w/2,h/2,d/2))\n\n            world_coords[j]  = v;\n            screen_coords[j] = hc2v(viewportMatrix * projectionMatrix * v2hc(v));\n        }\n\n        //Still simplified light intensity\n        Vec3f n = (world_coords[2]-world_coords[0])^(world_coords[1]-world_coords[0]);\n        n.normalize();\n        float intensity = n*light_dir;\n\n        if (intensity>0) {\n            printf(\"ok %d\\n\", ++cnt);\n            Vec2i uv[3];\n            for (int j = 0; j < 3; j++) uv[j] = model->uv(i, j);\n            drawSolidTriangle(Triangle2D<float>({screen_coords[0], screen_coords[1], screen_coords[2]}), uv, image, intensity, zbuffer);\n        }\n    }\n    ...\n}\n```\n\n\n\n\n\n效果\n\n![image-20240504170937200](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240504160940105-1636523864.png)\n\n\n\n\n\n注：TinyRenderer的透视投影与GAMES101处理方式不同，GAMES101是把M\\[3\\]\\[2\\]固定为1，求解M的第三行，而此处是固定第三行为（0 0 1 0），求解M\\[3\\]\\[2\\]。\n\n此处并没有“近平面”的概念，认为n=0,f=c。\n\n下面是GAMES101给出的结果（第三行为0 0 A B）：\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182227248-1392365094.png\" alt=\"image-20240505192224927\" style=\"zoom:50%;\" />\n\n\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182300021-22198105.png\" alt=\"image-20240505192257807\" style=\"zoom:50%;\" />\n\n\n\n## Lesson 5: Moving the camera\n\n之前，我们考虑了相机在(0,0,c)，朝着-z方向看的情况。\n\n对于任意的相机位置，需要三个向量来确定：相机坐标e，相机指向的点c，向上方向向量u,如图所示：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/b94dd4a591514fd66a91a6e4cc065644.png)\n\n我们假定相机总是朝着-z方向看，而u朝向正y方向，据此就得到了一个新的坐标系x'y'z'，\n\n下面考虑如何将物体坐标[x,y,z]转化为新坐标系下的[x',y',z']。\n\n\n\n\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f66a0139058ab1d1025dbfd8cd401389.png)\n\n首先回顾坐标[x,y,z]的定义，它是三个正交的单位向量i,j,k前面的系数\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f00.png)\n\n现在，我们有了新的单位向量i',j',k',那么一定存在矩阵M，使得\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f01.png)\n\n我们将OP写成OO'+O'P,与新的单位坐标建立联系：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f02.png)\n\n将[i',j',k']用上面的式子表示，提出[i,j,k]:\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f03.png)\n\n左边用[x,y,z]的定义式替换，就得到了[x',y',z']与[x,y,z]的关系\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f04.png)\n\n\n\n\n\n\n\n关于look at的推导，此处写的有些混乱\n建议参阅https://www.zhihu.com/question/447781866 \n\n下面是个人理解：\n\n简单来说，设M是(0, 0, 0),[i,j,k]到eyepos, [i',j',k']的变换矩阵\n则M=TR,先旋转后平移\n\n其中旋转矩阵R根据单位向量**左乘**该矩阵得到新单位向量，很容易得到(此处r,u,v是i',j',k'在原坐标系下的坐标)\n\n![image-20240505220527743](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505210530096-395261047.png)\n\n而T则为原点平移到eye pos的平移矩阵 （C是eyepos)\n\n![image-20240505221319762](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505211321938-1985120681.png)\n\n此为对坐标轴的变换矩阵，即，我们用M计算了**新的单位向量在原坐标系下的坐标**，而要得到原来单位向量在新坐标系下的坐标，显然应该左乘M的逆矩阵。这样，我们就求得了ModelView矩阵。\n\n\n\n据此，编写lookup实现modelview的计算\n\n```cpp\nVec3f light_dir = Vec3f(0, 0, -1).normalize();\nVec3f eye(1, 1, 3);\nVec3f center(0, 0, 0);\nVec3f up(0, 1, 0);\n//Vec3f camera(0, 0, 3);\n\n//screen_coordinate = viewport * projection * modelview * world_coordinate\nMatrix lookat(Vec3f eye, Vec3f center, Vec3f up) {\n    Vec3f z = (eye - center).normalize();\n    Vec3f x = (up ^ z).normalize();\n    Vec3f y = (z ^ x).normalize();\n    Matrix M_inv = Matrix::identity(4);\n    Matrix T = Matrix::identity(4);\n    //thanks https://www.zhihu.com/question/447781866\n    for (int i = 0; i < 3; i++) {\n        M_inv[0][i] = x[i];\n        M_inv[1][i] = y[i];\n        M_inv[2][i] = z[i];\n        T[i][3] = -eye[i];\n    }\n    return M_inv * T;\n}\n\n\nMatrix projection(Vec3f eye, Vec3f center) {\n    Matrix m = Matrix::identity(4);\n    m[3][2] = -1.f / (eye - center).norm();\n    //m[3][2] = -1.f / camera.z;\n    return m;\n}\n\n\nint main() {\n    ...\n        \n    Matrix modelviewMatrix = lookat(eye, center, up);\n    Matrix projectionMatrix = projection(eye, center);\n    Matrix viewportMatrix = viewport(width / 8, height / 8, width * 0.75, height * 0.75);\n\n    ...\n    screen_coords[j] = hc2v(viewportMatrix * projectionMatrix * modelviewMatrix * v2hc(v));\n    ...\n    \n}\n```\n\n效果 目前有点bug\n\n![image-20240505225818988](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505215822020-1676545529.png)\n\n\n\n\n\n\n### Bouns：Transformation of normal vectors\n\n为了处理光照，我们将模型进行坐标变换后，如果模型提供了每个面的法向量，还需要将法向量也进行变换。\n\n此处有一个结论：模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置。\n\n证明：考虑平面方程 Ax+By+Cz=0，它的法向量是（A,B,C) ,写成矩阵形式为：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f05.png)\n\n在两者之间插入M的逆和M：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f06.png)\n\n 由于坐标均为列向量，把左边写成转置形式：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f07.png)\n\n因此，如果对坐标(x,y,z)做变换M，要满足原来的直线方程，对法向量的变换矩阵为M的逆矩阵的转置（或者转置再求逆，转置和求逆是**可交换的**，证明略）\n\n## Lesson 6: Shaders \n\n本节主要分为两大部分：重构代码，实现不同的shaders。\n\n再尝试用自己之前的屎山适配Shader部分后，我放弃了，直接使用作者写的geometry。内容大部分都很直观，值得注意的是\n\n```cpp\ntemplate<size_t LEN,size_t DIM,typename T> vec<LEN,T> embed(const vec<DIM,T> &v, T fill=1) {\n    vec<LEN,T> ret;\n    for (size_t i=LEN; i--; ret[i]=(i<DIM?v[i]:fill));\n    return ret;\n}\n\ntemplate<size_t LEN,size_t DIM, typename T> vec<LEN,T> proj(const vec<DIM,T> &v) {\n    vec<LEN,T> ret;\n    for (size_t i=LEN; i--; ret[i]=v[i]);\n    return ret;\n}\n```\n\n这两个模板的作用，分别是将低维向量拓展到高维（不足补1）、高维向量投影到低维（截取前LEN个坐标），在涉及其次坐标和普通坐标的转换时多次用到。\n\n\n\n\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/OpenGL-2.0-Programmable-Shader-Pipeline.png)\n\n\n\nShader包含顶点着色和片元着色两个部件，将其抽离出来，可以使得我们通过修改Shader即可实现各种不同的渲染效果，而无需改动其他代码。\n\n在`gl.h`中，定义Shader的基本结构。不同Shader的通过继承基类重写两个虚函数来实现\n\n```cpp\nstruct IShader {\n    virtual ~IShader() {}\n    virtual Vec4f  vertex(int iface, int nthvert) = 0;\n    virtual bool fragment(Vec3f bar, TGAColor &color) = 0;\n};\n```\n\n其中，iface是面的编号，而nthvert是顶点编号（对于三角形为0,1,2）。\n\n例如，一个简单的GouraudShader，vertex通过顶点法向量与光照的点乘计算三角形每个顶点的光照，而fragment通过重心坐标插值计算三角形区域中所有像素的颜色。\n\n```cpp\nstruct GouraudShader : public IShader {\n    Vec3f varying_intensity;\n    //顶点着色\n    virtual Vec4f vertex(int iface, int nthvert) {\n        Vec4f glVertex = embed<4>(model->vert(iface, nthvert));\n        glVertex = Viewport * Projection * ModelView * glVertex;\n        //\n        varying_intensity[nthvert] = std::max(0.f, model->normal(iface, nthvert) * light_dir);\n        return glVertex;\n    }\n    //片段着色 用于drawTriangle \n    //这里的bar即baryCentric\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        float intensity = varying_intensity * bar;\n        color = TGAColor(255, 255, 255) * intensity;\n        return false;\t//返回值表示是否丢弃\n    }\n};\n\n//in main for every vertex\nGouraudShader shader;\nfor (int i=0; i<model->nfaces(); i++) {\n    std::vector<int> face = model->face(i);\n    Vec3f world_coords[3];\n    Vec4f screen_coords[3];\n    for (int j = 0; j < 3; j++) {\n        Vec3f v = model->vert(face[j]);\n        world_coords[j] = v;\n        screen_coords[j] = shader.vertex(i, j);\n    }\n    drawTriangle(screen_coords, shader, image, zbuffer);\n}\n// in drawTriangle, for every pixel\n...\nTGAColor color;\nbool discard = shader.fragment(bc, color);\nif (!discard) {\n    zbuffer.set(P.x, P.y, TGAColor(frag_depth));\n    image.set(P.x, P.y, color);\n}    \n...\n```\n\n所得的效果如图\n\n![image-20240512211917138](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512201920094-1588430460.png)\n\n我们可以轻松地修改着色器，实现不同的渲染效果，如将颜色设置为6个梯度的橙色：\n\n```cpp\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        float intensity = varying_intensity*bar;\n        if (intensity>.85) intensity = 1;\n        else if (intensity>.60) intensity = .80;\n        else if (intensity>.45) intensity = .60;\n        else if (intensity>.30) intensity = .45;\n        else if (intensity>.15) intensity = .30;\n        else intensity = 0;\n        color = TGAColor(255, 155, 0)*intensity;\n        return false;\n    }\n```\n\n效果：\n\n![image-20240512212544885](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202546531-812190877.png)\n\n**纹理着色器**\n\n接下来，我们可以实现漫反射纹理。只需要修改Shader添加纹理映射项即可。\n\n```cpp\nstruct TextureShader : public IShader {\n    Vec3f          varying_intensity; // written by vertex shader, read by fragment shader\n    mat<2,3,float> varying_uv;        // same as above\n\n    virtual Vec4f vertex(int iface, int nthvert) {\n        varying_uv.set_col(nthvert, model->uv(iface, nthvert));\n        varying_intensity[nthvert] = std::max(0.f, model->normal(iface, nthvert)*light_dir); // get diffuse lighting intensity\n        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert)); // read the vertex from .obj file\n        return Viewport*Projection*ModelView*gl_Vertex; // transform it to screen coordinates\n    }\n\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        float intensity = varying_intensity*bar;   // interpolate intensity for the current pixel\n        Vec2f uv = varying_uv*bar;                 // interpolate uv for the current pixel\n        color = model->diffuse(uv)*intensity;      // well duh\n        return false;                              // no, we do not discard this pixel\n    }\n};\n```\n\n效果\n\n![image-20240512212807641](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202811146-1791754725.png)\n\n**法线着色器**\n\n事实上，纹理图像中不止可以储存颜色，还可以储存法线方向、温度等等信息。通过纹理给出每个点的法线方向，就能实现表明的凹凸起伏效果。此时，纹理图像的RGB值不再储存颜色，而是用于储存法线，如下图。\n\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/african_head_nm.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n上节课的结尾，我们提到了“模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置”这一结论，根据这个结论，就可以直接在顶点着色器中分别计算顶点和法向量经过投影后的结构\n\n```cpp\nstruct NormalShader : public IShader {\n    mat<2,3,float> varying_uv;  // same as above\n    mat<4,4,float> uniform_M;   //  Projection*ModelView\n    mat<4,4,float> uniform_MIT; // (Projection*ModelView).invert_transpose()\n\n    virtual Vec4f vertex(int iface, int nthvert) {\n        varying_uv.set_col(nthvert, model->uv(iface, nthvert));\n        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert)); // read the vertex from .obj file\n        return Viewport*Projection*ModelView*gl_Vertex; // transform it to screen coordinates\n   }\n\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        Vec2f uv = varying_uv*bar;                 // interpolate uv for the current pixel\n        Vec3f n = proj<3>(uniform_MIT*embed<4>(model->normal(uv))).normalize();\n        Vec3f l = proj<3>(uniform_M  *embed<4>(light_dir        )).normalize();\n        float intensity = std::max(0.f, n*l);\n        color = model->diffuse(uv)*intensity;      // well duh\n        return false;                              // no, we do not discard this pixel\n    }\n};\n```\n\n效果：\n\n![image-20240512214259167](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512204303617-1448246807.png)\n\n\n\n**Phone模型着色器**\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/e3720a5dfedc49edb0bf70f8bc64204a.png)\n\n根据Phone光照模型，物体的真实光照可以近似为环境光+漫反射+高光。据此，我们可以进一步得出更加真实的着色器。\n\n高光的计算如图所示：\n\n![img](https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/d58cd3bbab46463e87b782a12a147fbb.png)\n\n已知物体表明法向量为n，入射光为l，两者夹角为a，假设所有向量都被归一化，设反射光为r，则有l+r=2n cosa ，可求得反射光r=2n cosa - l = 2n(n·l)-l。反射光\n\n```cpp\nstruct PhoneShader : public IShader {\n    mat<2,3,float> varying_uv;  // same as above\n    mat<4,4,float> uniform_M;   //  Projection*ModelView\n    mat<4,4,float> uniform_MIT; // (Projection*ModelView).invert_transpose()\n\n    virtual Vec4f vertex(int iface, int nthvert) {\n        varying_uv.set_col(nthvert, model->uv(iface, nthvert));\n        Vec4f gl_Vertex = embed<4>(model->vert(iface, nthvert)); // read the vertex from .obj file\n        return Viewport*Projection*ModelView*gl_Vertex; // transform it to screen coordinates\n    }\n\n    virtual bool fragment(Vec3f bar, TGAColor &color) {\n        Vec2f uv = varying_uv*bar;\n        Vec3f n = proj<3>(uniform_MIT*embed<4>(model->normal(uv))).normalize();\n        Vec3f l = proj<3>(uniform_M  *embed<4>(light_dir        )).normalize();\n        Vec3f r = (n*(n*l*2.f) - l).normalize();   // reflected light\n        float spec = pow(std::max(r.z, 0.0f), model->specular(uv));\n        float diff = std::max(0.f, n*l);\n        TGAColor c = model->diffuse(uv);\n        color = c;\n        for (int i=0; i<3; i++) color[i] = std::min<float>(5 + c[i]*(diff + .6*spec), 255);\n        return false;\n    }\n};\n```\n\n按照环境光5+自身颜色*(1漫反射+0.6高光)，得到的效果如下\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512210513789-778169408.png\" alt=\"image-20240512220509696\" style=\"zoom:67%;\" />\n\n我们可以试试其他的配比系数，如`10 + c[i]*(2 * diff + 1.5*spec`\n\n![image-20240512221918507](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211926468-1109783721.png)\n\n另外，我们还可以到master分支找其他的模型，尝试渲染效果\n\n![image-20240512221509093](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211511558-935691911.png)\n\n\n\n![image-20240512222416047](https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512212417887-506051993.png)","slug":"TinyRendererNotes","published":1,"updated":"2025-08-26T06:13:21.746Z","comments":1,"layout":"post","photos":[],"_id":"cmes8p36c0006lkw914m0fscw","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n<h2 id=\"TinyRender学习笔记\"><a href=\"#TinyRender学习笔记\" class=\"headerlink\" title=\"TinyRender学习笔记\"></a>TinyRender学习笔记</h2><p>通过手写软光栅渲染器加深对计算机图形学基本原理的理解，并练习C++面向对象程序设计。</p>\n<p>该项目主要参考<a href=\"https://github.com/ssloy/tinyrenderer/wiki\">Home · ssloy&#x2F;tinyrenderer Wiki (github.com)</a>编写，使用CMake构建</p>\n<p>可以浏览我的历史commit，找到不同进度时提交的代码。</p>\n<p>本项目涉及的几乎所有的图形学知识都在GAMES101课程中出现过，推荐将GAMES101作为前置课程，或配合GAMES101的进度一起学习。</p>\n<h2 id=\"Lesson-0-Getting-Started\"><a href=\"#Lesson-0-Getting-Started\" class=\"headerlink\" title=\"Lesson 0 Getting Started\"></a>Lesson 0 Getting Started</h2><h3 id=\"Using-TGA-image-format\"><a href=\"#Using-TGA-image-format\" class=\"headerlink\" title=\"Using TGA image format\"></a>Using TGA image format</h3><p>使用这个基本框架来生成TGA格式图像：<br><a href=\"https://github.com/ssloy/tinyrenderer/tree/909fe20934ba5334144d2c748805690a1fa4c89f\">ssloy&#x2F;tinyrenderer at 909fe20934ba5334144d2c748805690a1fa4c89f (github.com)</a></p>\n<p>只需 <code>#include &quot;tgaimage.h&quot;</code> ，并在编译时链接tgaimage.cpp即可。</p>\n<p>例：在屏幕上将像素(52,41)设置为红色</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;tgaimage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">//Set color with RGB</span></span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor white = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor red   = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>,   <span class=\"number\">0</span>,   <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//Set image size</span></span><br><span class=\"line\">        <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(<span class=\"number\">100</span>, <span class=\"number\">100</span>, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//Set pixel color</span></span><br><span class=\"line\">        image.<span class=\"built_in\">set</span>(<span class=\"number\">52</span>, <span class=\"number\">41</span>, red);</span><br><span class=\"line\">        <span class=\"comment\">//To have the origin at the left bottom corner of the image</span></span><br><span class=\"line\">        image.<span class=\"built_in\">flip_vertically</span>(); </span><br><span class=\"line\">        image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>个人推荐的环境：Clion + CMake。（因为VsCode CMake调试功能实在搞不懂&#x3D;.&#x3D;)</p>\n<p>涉及导入模型，需要将工作目录设置为工程文件夹</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220018544-333214793.png\" alt=\"image-20240505230016266\"></p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220047826-450326712.png\" alt=\"image-20240505230043985\"></p>\n<p>但我的Clion存在tga图像无法加载的bug。在设置-&gt;编辑器-&gt;文件类型中去掉.tga，然后选择用本地程序打开即可。</p>\n<h2 id=\"Lesson-1-Bresenham’s-Line-Drawing-Algorithm\"><a href=\"#Lesson-1-Bresenham’s-Line-Drawing-Algorithm\" class=\"headerlink\" title=\"Lesson 1 Bresenham’s Line Drawing Algorithm\"></a>Lesson 1 Bresenham’s Line Drawing Algorithm</h2><p>使用Bresenham算法绘制线段。</p>\n<p>原理：<a href=\"https://en.wikipedia.org/wiki/Bresenham's_line_algorithm\">https://en.wikipedia.org/wiki/Bresenham&#39;s_line_algorithm</a></p>\n<p>实现参考：<a href=\"https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C++\">https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C++</a></p>\n<p>建议绘制斜率小于-1，-1到0,0到1,大于1，以及水平和垂直的直线来检验算法正确性。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;tgaimage.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor white = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor red = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor blue = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">line</span><span class=\"params\">(<span class=\"type\">int</span> x1, <span class=\"type\">int</span> y1, <span class=\"type\">int</span> x2, <span class=\"type\">int</span> y2, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Ensure that slope in (0, 1)</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> steep = (std::<span class=\"built_in\">abs</span>(y2 - y1) &gt; std::<span class=\"built_in\">abs</span>(x2 - x1));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (steep) &#123;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(x1, y1);</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(x2, y2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x1 &gt; x2) &#123;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(x1, x2);</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(y1, y2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">float</span> dx = x2 - x1;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">float</span> dy = <span class=\"built_in\">fabs</span>(y2 - y1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> error = dx / <span class=\"number\">2.0f</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> ystep = (y1 &lt; y2) ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = (<span class=\"type\">int</span>)y1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> maxX = (<span class=\"type\">int</span>)x2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = (<span class=\"type\">int</span>)x1; x &lt;= maxX; x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (steep) &#123;</span><br><span class=\"line\">            image.<span class=\"built_in\">set</span>(y, x, color);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            image.<span class=\"built_in\">set</span>(x, y, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error -= dy;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            y += ystep;</span><br><span class=\"line\">            error += dx;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(<span class=\"number\">100</span>, <span class=\"number\">100</span>, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">13</span>, <span class=\"number\">20</span>, <span class=\"number\">80</span>, <span class=\"number\">40</span>, image, red);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">55</span>, <span class=\"number\">33</span>, <span class=\"number\">22</span>, <span class=\"number\">66</span>, image, blue);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">33</span>, <span class=\"number\">33</span>, <span class=\"number\">66</span>, <span class=\"number\">66</span>, image, white);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">44</span>, <span class=\"number\">20</span>, <span class=\"number\">44</span>, <span class=\"number\">80</span>, image, white);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">20</span>, <span class=\"number\">44</span>, <span class=\"number\">80</span>, <span class=\"number\">44</span>, image, white);</span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419173705372-1981687689.png\" alt=\"image-20240419183705501\"></p>\n<h2 id=\"Lesson-2-Triangle-rasterization-and-back-face-culling\"><a href=\"#Lesson-2-Triangle-rasterization-and-back-face-culling\" class=\"headerlink\" title=\"Lesson 2: Triangle rasterization and back face culling\"></a>Lesson 2: Triangle rasterization and back face culling</h2><p>三维物体模型通常以三角形为基础。为了方便表示点、向量、多边形，写geometry.h。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">Vec2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;t u, v;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;t x, y;&#125;;</span><br><span class=\"line\">        t raw[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">Vec2</span>() : <span class=\"built_in\">u</span>(<span class=\"number\">0</span>), <span class=\"built_in\">v</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Vec2</span>(t _u, t _v) : <span class=\"built_in\">u</span>(_u),<span class=\"built_in\">v</span>(_v) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec2&lt;t&gt; <span class=\"keyword\">operator</span> +(<span class=\"type\">const</span> Vec2&lt;t&gt; &amp;V) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec2</span>&lt;t&gt;(u+V.u, v+V.v); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec2&lt;t&gt; <span class=\"keyword\">operator</span> -(<span class=\"type\">const</span> Vec2&lt;t&gt; &amp;V) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec2</span>&lt;t&gt;(u-V.u, v-V.v); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec2&lt;t&gt; <span class=\"keyword\">operator</span> *(<span class=\"type\">float</span> f)          <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec2</span>&lt;t&gt;(u*f, v*f); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> &gt; <span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec2&lt;t&gt;&amp; v);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">Vec3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;t x, y, z;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123; t ivert, iuv, inorm; &#125;;</span><br><span class=\"line\">        t raw[<span class=\"number\">3</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">Vec3</span>() : <span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>), <span class=\"built_in\">z</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Vec3</span>(t _x, t _y, t _z) : <span class=\"built_in\">x</span>(_x),<span class=\"built_in\">y</span>(_y),<span class=\"built_in\">z</span>(_z) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> ^(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> +(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(x+v.x, y+v.y, z+v.z); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> -(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(x-v.x, y-v.y, z-v.z); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> *(<span class=\"type\">float</span> f)          <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(x*f, y*f, z*f); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> t       <span class=\"keyword\">operator</span> *(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> x*v.x + y*v.y + z*v.z; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">norm</span> <span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> std::<span class=\"built_in\">sqrt</span>(x*x+y*y+z*z); &#125;</span><br><span class=\"line\">    <span class=\"function\">Vec3&lt;t&gt; &amp; <span class=\"title\">normalize</span><span class=\"params\">(t l=<span class=\"number\">1</span>)</span> </span>&#123; *<span class=\"keyword\">this</span> = (*<span class=\"keyword\">this</span>)*(l/<span class=\"built_in\">norm</span>()); <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> &gt; <span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec3&lt;t&gt;&amp; v);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec2&lt;<span class=\"type\">float</span>&gt; Vec2f;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec2&lt;<span class=\"type\">int</span>&gt;   Vec2i;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec3&lt;<span class=\"type\">float</span>&gt; Vec3f;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec3&lt;<span class=\"type\">int</span>&gt;   Vec3i;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec2&lt;t&gt;&amp; v) &#123;</span><br><span class=\"line\">    s &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec3&lt;t&gt;&amp; v) &#123;</span><br><span class=\"line\">    s &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; v.z &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如何画出实心的三角形？一般来说，有扫描线和边界函数两种算法。</p>\n<p>对于多线程的CPU,采用边界函数法更为高效：先找到三角形的矩形包围盒，再逐点判断是否在三角形中</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">triangle</span>(vec2 points[<span class=\"number\">3</span>]) &#123; </span><br><span class=\"line\">    vec2 bbox[<span class=\"number\">2</span>] = <span class=\"built_in\">find_bounding_box</span>(points); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (each pixel in the bounding box) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">inside</span>(points, pixel)) &#123; </span><br><span class=\"line\">            <span class=\"built_in\">put_pixel</span>(pixel); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，问题变成了给定三角形的三个点，如何判断点是否在三角形内部</p>\n<p>一种最好的办法是，计算给定点关于给定三角形的重心坐标（或者叫面积坐标）。</p>\n<p>维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87\">https://zh.wikipedia.org/wiki/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87</a></p>\n<p>简单来说，它表示一个点所对的三条边形成的三角形面积比。如果点在三角形外部，则有一个维度是负的。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419175823218-1822502417.png\" alt=\"image-20240419185822971\"></p>\n<p>由于tinyrenderer的作者写得有些丑陋，我在geometry.h里直接加入了polygon和triangle类，来实现重心坐标计算和点在三角形内的检测</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Polygon2D</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    std::vector&lt;Vec2&lt;T&gt;&gt; pt;</span><br><span class=\"line\">    <span class=\"built_in\">Polygon2D</span>(<span class=\"type\">int</span> _n, std::vector&lt;Vec2&lt;T&gt;&gt; _pt): <span class=\"built_in\">n</span>(_n), <span class=\"built_in\">pt</span>(_pt) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Triangle2D</span>: <span class=\"keyword\">public</span> Polygon2D&lt;T&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Polygon2D&lt;T&gt;::pt;</span><br><span class=\"line\">    <span class=\"built_in\">Triangle2D</span>(std::vector&lt;Vec2&lt;T&gt;&gt; _pt): <span class=\"built_in\">Polygon2D</span>&lt;T&gt;(<span class=\"number\">3</span>, _pt) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">baryCentric</span><span class=\"params\">(Vec2i P)</span> </span>&#123;</span><br><span class=\"line\">        Vec3f u = <span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>]-P[<span class=\"number\">0</span>])^<span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>]-P[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">/* `pts` and `P` has integer value as coordinates</span></span><br><span class=\"line\"><span class=\"comment\">           so `abs(u[2])` &lt; 1 means `u[2]` is 0, that means</span></span><br><span class=\"line\"><span class=\"comment\">           triangle is degenerate, in this case return something with negative coordinates */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(u.z)&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">inInside</span><span class=\"params\">(Vec2i P)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> bc = <span class=\"built_in\">baryCentric</span>(P);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bc.x&lt;<span class=\"number\">0</span> || bc.y&lt;<span class=\"number\">0</span> || bc.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在main.cpp里绘制实心三角形</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">drawSolidTriangle</span><span class=\"params\">(Triangle2D&lt;<span class=\"type\">int</span>&gt; tri, TGAImage &amp;image, TGAColor color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vec2i <span class=\"title\">bboxmin</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>,  image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2i <span class=\"title\">bboxmax</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2i <span class=\"title\">clamp</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>, image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        bboxmin.x = std::<span class=\"built_in\">max</span>(<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmin.y = std::<span class=\"built_in\">max</span>(<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.y, tri.pt[i].y));</span><br><span class=\"line\"></span><br><span class=\"line\">        bboxmax.x = std::<span class=\"built_in\">min</span>(clamp.x, std::<span class=\"built_in\">max</span>(bboxmax.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmax.y = std::<span class=\"built_in\">min</span>(clamp.y, std::<span class=\"built_in\">max</span>(bboxmax.y, tri.pt[i].y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Vec2i P;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class=\"line\">            Vec3f bc_screen  = tri.<span class=\"built_in\">baryCentric</span>(P);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bc_screen.x&lt;<span class=\"number\">0</span> || bc_screen.y&lt;<span class=\"number\">0</span> || bc_screen.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>得到如图效果：</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419185714797-2050127591.png\" alt=\"image-20240419195714296\" style=\"zoom:50%;\">\n\n<p>三角形绘制完成后，可以尝试导入作者提供的由三角形构成的人脸模型。</p>\n<p>.obj模型文件的格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># List of geometric vertices, with (x, y, z, [w]) coordinates, w is optional and defaults to 1.0.</span><br><span class=\"line\">v 0.123 0.234 0.345 1.0</span><br><span class=\"line\">v ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># List of texture coordinates, in (u, [v, w]) coordinates, these will vary between 0 and 1. v, w are optional and default to 0.</span><br><span class=\"line\">vt 0.500 1 [0]</span><br><span class=\"line\">vt ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># List of vertex normals in (x,y,z) form; normals might not be unit vectors.</span><br><span class=\"line\">vn 0.707 0.000 0.707</span><br><span class=\"line\">vn ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># Parameter space vertices in (u, [v, w]) form; free form geometry statement (see below)</span><br><span class=\"line\">vp 0.310000 3.210000 2.100000</span><br><span class=\"line\">vp ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># Polygonal face element (see below)</span><br><span class=\"line\">f 1 2 3</span><br><span class=\"line\">f 3/1 4/2 5/3</span><br><span class=\"line\">f 6/4/1 3/5/3 7/6/5</span><br><span class=\"line\">f 7//1 8//2 9//3</span><br><span class=\"line\">f ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># Line element (see below)</span><br><span class=\"line\">l 5 8 1 2 4 9</span><br></pre></td></tr></table></figure>\n\n<p>目前，我们暂时不关心模型的深度（z坐标），只是将模型正投影到XY平面上，则模型上的点对应的屏幕坐标可以这样简单的计算</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">screen_coords[j] = <span class=\"built_in\">Vec2i</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>, (v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>);</span><br></pre></td></tr></table></figure>\n\n<p>假设光从正前方射向正后方，即光线方向(0,0,-1)。</p>\n<p>在这里，我们使用一种简化的亮度计算方法：我们忽略面与光源之间的距离差异，认为正对着光源的面（法线与光线方向相同）最亮，这样就可以计算每个三角形面的单位法向量与光线方向的叉积来代表亮度。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span>==argc) &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(<span class=\"string\">&quot;obj/african_head.obj&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(width, height, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec2i screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">Vec2i</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>, (v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>);</span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">int</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), image, <span class=\"built_in\">TGAColor</span>(intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, <span class=\"number\">255</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> model;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种简化下，得到的渲染结果如下：<br><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419195642124-634629665.png\" alt=\"image-20240419205641217\"></p>\n<p>可以发现，位于口腔中的三角形遮住了嘴唇。下一节课中，我们将考虑深度测试，正确处理多边形的遮挡关系。</p>\n<h2 id=\"Lesson-3-Z-Buffer\"><a href=\"#Lesson-3-Z-Buffer\" class=\"headerlink\" title=\"Lesson 3: Z Buffer\"></a>Lesson 3: Z Buffer</h2><p>深度检测算法的基本原理是，引入一个大小为像素数量的Z-Buffer数组，初始化所有像素点深度为负无穷。</p>\n<p>在遍历像素点时，比较当前三角形上点的深度是否小于Z-Buffer的数值，如果小于，则更新该像素并更新Z-Buffer。</p>\n<p>为此，我们需要为屏幕坐标增加一维深度（对于上面的人脸设置为模型的z即可）。在drawSolidTriangle()中增加对深度缓冲区的判断。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside</span></span><br><span class=\"line\"><span class=\"comment\">// 2024 04 26 2d-&gt;3d</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">drawSolidTriangle</span><span class=\"params\">(Triangle2D&lt;<span class=\"type\">float</span>&gt; tri, TGAImage &amp;image, TGAColor color, <span class=\"type\">float</span> *zbuffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmin</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>,  image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmax</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">clamp</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>, image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        bboxmin.x = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmin.y = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.y, tri.pt[i].y));</span><br><span class=\"line\"></span><br><span class=\"line\">        bboxmax.x = std::<span class=\"built_in\">min</span>(clamp.x, std::<span class=\"built_in\">max</span>(bboxmax.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmax.y = std::<span class=\"built_in\">min</span>(clamp.y, std::<span class=\"built_in\">max</span>(bboxmax.y, tri.pt[i].y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Vec3i P;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class=\"line\">            Vec3f bc_screen  = tri.<span class=\"built_in\">baryCentric</span>(P.<span class=\"built_in\">toVec2</span>());<span class=\"comment\">//toTriangle2D().baryCentric(P);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bc_screen.x&lt;<span class=\"number\">0</span> || bc_screen.y&lt;<span class=\"number\">0</span> || bc_screen.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//bugfix</span></span><br><span class=\"line\">            P.z = tri.depth[<span class=\"number\">0</span>] * bc.x + tri.depth[<span class=\"number\">1</span>] * bc.y + tri.depth[<span class=\"number\">2</span>] * bc.z;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> idx = P.x+P.y*width;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zbuffer[idx]&lt;P.z) &#123;</span><br><span class=\"line\">                zbuffer[idx] = P.z;</span><br><span class=\"line\">                image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">worldToScreen</span><span class=\"params\">(Vec3f v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"built_in\">int</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), <span class=\"built_in\">int</span>((v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), v.z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span>==argc) &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(<span class=\"string\">&quot;obj/african_head.obj&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> *zbuffer = <span class=\"keyword\">new</span> <span class=\"type\">float</span>[width * height];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=width*height; i--; zbuffer[i] = -std::numeric_limits&lt;<span class=\"type\">float</span>&gt;::<span class=\"built_in\">max</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(width, height, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec3f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            <span class=\"comment\">//screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);</span></span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">worldToScreen</span>(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">float</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), image, <span class=\"built_in\">TGAColor</span>(intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, <span class=\"number\">255</span>), zbuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> model;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时，在Triangle2D类中加入depth数组即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Triangle2D</span>: <span class=\"keyword\">public</span> Polygon2D&lt;T&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Polygon2D&lt;T&gt;::pt;</span><br><span class=\"line\">    std::vector&lt;T&gt; depth;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Triangle2D</span>(std::vector&lt;Vec2&lt;T&gt;&gt; _pt, std::vector&lt;Vec2&lt;T&gt;&gt; _depth = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;): </span><br><span class=\"line\">        <span class=\"built_in\">Polygon2D</span>&lt;T&gt;(<span class=\"number\">3</span>, _pt), </span><br><span class=\"line\">        <span class=\"built_in\">depth</span>(_depth) &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">Triangle2D</span>(std::vector&lt;Vec3&lt;<span class=\"type\">float</span>&gt;&gt; _pt):</span><br><span class=\"line\">        <span class=\"built_in\">Polygon2D</span>&lt;T&gt;(<span class=\"number\">3</span>, &#123;_pt[<span class=\"number\">0</span>].<span class=\"built_in\">toVec2</span>(), _pt[<span class=\"number\">1</span>].<span class=\"built_in\">toVec2</span>(), _pt[<span class=\"number\">2</span>].<span class=\"built_in\">toVec2</span>()&#125;),</span><br><span class=\"line\">        <span class=\"built_in\">depth</span>(&#123;_pt[<span class=\"number\">0</span>].z, _pt[<span class=\"number\">1</span>].z, _pt[<span class=\"number\">2</span>].z&#125;) &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">baryCentric</span><span class=\"params\">(Vec2f P)</span> </span>&#123;</span><br><span class=\"line\">        Vec3f u = <span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>]-P[<span class=\"number\">0</span>])^<span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>]-P[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">/* `pts` and `P` has integer value as coordinates</span></span><br><span class=\"line\"><span class=\"comment\">           so `abs(u[2])` &lt; 1 means `u[2]` is 0, that means</span></span><br><span class=\"line\"><span class=\"comment\">           triangle is degenerate, in this case return something with negative coordinates */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(u.z)&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">inInside</span><span class=\"params\">(Vec2i P)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> bc = <span class=\"built_in\">baryCentric</span>(P);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bc.x&lt;<span class=\"number\">0</span> || bc.y&lt;<span class=\"number\">0</span> || bc.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果如图所示：<br><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426165741120-55012551.png\" alt=\"image-20240426175739547\"></p>\n<h3 id=\"Bouns-Texture-Mapping\"><a href=\"#Bouns-Texture-Mapping\" class=\"headerlink\" title=\"Bouns: Texture Mapping\"></a>Bouns: Texture Mapping</h3><p>在.obj文件中，有以“vt u v”开头的行，它们给出了一个纹理坐标数组。 </p>\n<blockquote>\n<p>The number in the middle (between the slashes) in the facet lines “f x&#x2F;x&#x2F;x x&#x2F;x&#x2F;x x&#x2F;x&#x2F;x” are the texture coordinates of this vertex of this triangle. Interpolate it inside the triangle, multiply by the width-height of the texture image and you will get the color to put in your render.</p>\n</blockquote>\n<p>tinyrender作者提供了漫反射纹理： <a href=\"..%5CDownloads%5Cafrican_head_diffuse.tga\">african_head_diffuse.tga</a> </p>\n<p>据此，我们可以给上述人脸模型添加纹理。此时，main函数中drawSolidTriangle函数里不需要再传入颜色，只需要传入intensity即可，另外需要传入当前三角形三个点的纹理坐标uv。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside</span></span><br><span class=\"line\"><span class=\"comment\">// 2024 04 26 2d-&gt;3d, texture mapping</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">drawSolidTriangle</span><span class=\"params\">(Triangle2D&lt;<span class=\"type\">float</span>&gt; tri, Vec2i* uv, TGAImage &amp;image, <span class=\"type\">float</span> intensity, <span class=\"type\">float</span> *zbuffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmin</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>,  image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmax</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">clamp</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>, image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        bboxmin.x = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmin.y = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.y, tri.pt[i].y));</span><br><span class=\"line\"></span><br><span class=\"line\">        bboxmax.x = std::<span class=\"built_in\">min</span>(clamp.x, std::<span class=\"built_in\">max</span>(bboxmax.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmax.y = std::<span class=\"built_in\">min</span>(clamp.y, std::<span class=\"built_in\">max</span>(bboxmax.y, tri.pt[i].y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Vec3i P;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class=\"line\">            Vec3f bc  = tri.<span class=\"built_in\">baryCentric</span>(P.<span class=\"built_in\">toVec2</span>());<span class=\"comment\">//toTriangle2D().baryCentric(P);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bc.x&lt;<span class=\"number\">0</span> || bc.y&lt;<span class=\"number\">0</span> || bc.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            P.z = tri.depth[<span class=\"number\">0</span>] * bc.x + tri.depth[<span class=\"number\">1</span>] * bc.y + tri.depth[<span class=\"number\">2</span>] * bc.z;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> idx = P.x+P.y*width;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zbuffer[idx]&lt;P.z) &#123;</span><br><span class=\"line\">                zbuffer[idx] = P.z;</span><br><span class=\"line\"></span><br><span class=\"line\">                Vec2i P_uv = uv[<span class=\"number\">0</span>] * bc.x + uv[<span class=\"number\">1</span>] * bc.y + uv[<span class=\"number\">2</span>] * bc.z;</span><br><span class=\"line\">                TGAColor color = model-&gt;<span class=\"built_in\">diffuse</span>(P_uv);</span><br><span class=\"line\">                image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">worldToScreen</span><span class=\"params\">(Vec3f v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"built_in\">int</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), <span class=\"built_in\">int</span>((v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), v.z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span>==argc) &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(<span class=\"string\">&quot;obj/african_head.obj&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> *zbuffer = <span class=\"keyword\">new</span> <span class=\"type\">float</span>[width * height];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=width*height; i--; zbuffer[i] = -std::numeric_limits&lt;<span class=\"type\">float</span>&gt;::<span class=\"built_in\">max</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(width, height, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec3f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            <span class=\"comment\">//screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);</span></span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">worldToScreen</span>(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            Vec2i uv[<span class=\"number\">3</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) uv[j] = model-&gt;<span class=\"built_in\">uv</span>(i, j);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">float</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), uv, image, intensity, zbuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> model;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>model.h和model.cpp需要修改以支持纹理。作者在lesson4的结尾放出了代码。</p>\n<p>效果：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426180250012-1899969424.png\" alt=\"image-20240426190246539\"></p>\n<p>这是一个平行投影的结果，损失了一部分真实感，例如，虽然耳朵旁边的头发在xoy平面上不与脸部重叠，但实际上应该被前边的皮肤遮挡，因为人眼&#x2F;相机本身是“点光源”，而不是“平行光源”，物体发出的光线最终汇聚于一点，也就是所谓的“透视”。下面将引入透视投影：</p>\n<h2 id=\"Lesson-4-Perspective-projection\"><a href=\"#Lesson-4-Perspective-projection\" class=\"headerlink\" title=\"Lesson 4: Perspective projection\"></a>Lesson 4: Perspective projection</h2><p>齐次坐标</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f10.png\" alt=\"img\"></p>\n<p>简单变换（图来自GAMES101）</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505164930200-682100308.png\" alt=\"image-20240505174927834\"></p>\n<p>逆变换</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165458526-1584226714.png\" alt=\"image-20240505175454080\"></p>\n<p>复合变换</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165021790-531013206.png\" alt=\"image-20240505175019922\"></p>\n<p>实现矩阵类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> DEFAULT_D = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Matrix</span> &#123;</span><br><span class=\"line\">    std::vector&lt;std::vector&lt;<span class=\"type\">float</span>&gt;&gt; m;</span><br><span class=\"line\">    <span class=\"type\">int</span> nrow, ncol;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Matrix</span>(<span class=\"type\">int</span> r=DEFAULT_D, <span class=\"type\">int</span> c=DEFAULT_D) :</span><br><span class=\"line\">        <span class=\"built_in\">m</span>(std::vector&lt;std::vector&lt;<span class=\"type\">float</span>&gt;&gt; (r, std::<span class=\"built_in\">vector</span>&lt;<span class=\"type\">float</span>&gt;(c, <span class=\"number\">0.f</span>))),</span><br><span class=\"line\">        <span class=\"built_in\">nrow</span>(r), <span class=\"built_in\">ncol</span>(c) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_nrow</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nrow; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_ncol</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> ncol; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> Matrix <span class=\"title\">identity</span><span class=\"params\">(<span class=\"type\">int</span> dimensions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">E</span><span class=\"params\">(dimensions, dimensions)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; dimensions; i++)</span><br><span class=\"line\">            E[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> E;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">float</span>&gt;&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">const</span> <span class=\"type\">int</span> i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt; nrow);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> std::vector&lt;<span class=\"type\">float</span>&gt;&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">const</span> <span class=\"type\">int</span> i) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt; nrow);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Matrix <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Matrix&amp; a) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"keyword\">this</span>-&gt;ncol == a.nrow);</span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">res</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;nrow, a.ncol)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>-&gt;nrow; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; a.ncol; j++) &#123;</span><br><span class=\"line\">                res.m[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"keyword\">this</span>-&gt;ncol; k++)</span><br><span class=\"line\">                    res.m[i][j] += <span class=\"keyword\">this</span>-&gt;m[i][k]*a.m[k][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Matrix <span class=\"title\">transpose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">res</span><span class=\"params\">(ncol, nrow)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ncol; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; nrow; j++)</span><br><span class=\"line\">                res.m[i][j] = m[j][i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">Matrix <span class=\"title\">inverse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(nrow==ncol);</span><br><span class=\"line\">        <span class=\"comment\">// augmenting the square matrix with the identity matrix of the same dimensions a =&gt; [ai]</span></span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">result</span><span class=\"params\">(nrow, ncol*<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;ncol; j++)</span><br><span class=\"line\">                result[i][j] = m[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow; i++)</span><br><span class=\"line\">            result[i][i+ncol] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// first pass</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// normalize the first row</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=result.ncol<span class=\"number\">-1</span>; j&gt;=<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">                result[i][j] /= result[i][i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=i+<span class=\"number\">1</span>; k&lt;nrow; k++) &#123;</span><br><span class=\"line\">                <span class=\"type\">float</span> coeff = result[k][i];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;result.ncol; j++) &#123;</span><br><span class=\"line\">                    result[k][j] -= result[i][j]*coeff;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// normalize the last row</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=result.ncol<span class=\"number\">-1</span>; j&gt;=nrow<span class=\"number\">-1</span>; j--)</span><br><span class=\"line\">            result[nrow<span class=\"number\">-1</span>][j] /= result[nrow<span class=\"number\">-1</span>][nrow<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// second pass</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=nrow<span class=\"number\">-1</span>; i&gt;<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=i<span class=\"number\">-1</span>; k&gt;=<span class=\"number\">0</span>; k--) &#123;</span><br><span class=\"line\">                <span class=\"type\">float</span> coeff = result[k][i];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;result.ncol; j++) &#123;</span><br><span class=\"line\">                    result[k][j] -= result[i][j]*coeff;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// cut the identity matrix back</span></span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">truncate</span><span class=\"params\">(nrow, ncol)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;ncol; j++)</span><br><span class=\"line\">                truncate[i][j] = result[i][j+ncol];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> truncate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Matrix&amp; m);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Matrix&amp; m) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m.nrow; i++)  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m.ncol; j++) &#123;</span><br><span class=\"line\">            s &lt;&lt; m[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j&lt;m.ncol<span class=\"number\">-1</span>) s &lt;&lt; <span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>一个简单投影矩阵的推导：</p>\n<p>假设相机位置为（0,0,c）成像平面为z&#x3D;0，如图</p>\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/525d3930435c3be900e4c7956edb5a1c.png\" alt=\"img\" style=\"zoom: 67%;\">\n\n\n\n<p>根据三角形相似，x’&#x2F;c &#x3D; x&#x2F;(c-z)，即有</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f15.png\" alt=\"img\"></p>\n<p>同理</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f16.png\" alt=\"img\"></p>\n<p>为了实现z轴方向上靠近相机的线段被拉伸，远离相机的线段被压缩，投影矩阵具有这样的形式</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f13.png\" alt=\"img\"></p>\n<p>根据齐次坐标的结果，得到对应的投影点坐标</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f14.png\" alt=\"img\"></p>\n<p>根据上面的结果，可知r&#x3D;-1&#x2F;c。</p>\n<p>我们可以得到一个简单情况下的投影矩阵，变换过程如图</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f17.png\" alt=\"img\"></p>\n<p>在程序中，这个过程用如下方式实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">screen_coords[j] = <span class=\"built_in\">hc2v</span>(viewportMatrix * projectionMatrix * <span class=\"built_in\">v2hc</span>(v));</span><br></pre></td></tr></table></figure>\n\n<p>(普通坐标 → 齐次坐标)</p>\n<p>世界坐标 → (经投影变换)投影坐标 → （经视口变换)屏幕坐标 </p>\n<p>(齐次坐标 → 普通坐标)</p>\n<p>这里的坐标包含位置(x,y)和深度z,深度交给z-buffer来处理</p>\n<p>视口变化的目的是将投影区域映射到[-1,1]^3的立方体中，便于绘制</p>\n<p>相关变化的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Transition between coordinates (vector type) and homogeneous coordinates (matrix type)</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">v2hc</span><span class=\"params\">(<span class=\"type\">const</span> Vec3f &amp;v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Matrix <span class=\"title\">hc</span><span class=\"params\">(<span class=\"number\">4</span>, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    hc[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = v.x;</span><br><span class=\"line\">    hc[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = v.y;</span><br><span class=\"line\">    hc[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = v.z;</span><br><span class=\"line\">    hc[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">hc2v</span><span class=\"params\">(<span class=\"type\">const</span> Matrix &amp;hc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(hc[<span class=\"number\">0</span>][<span class=\"number\">0</span>], hc[<span class=\"number\">1</span>][<span class=\"number\">0</span>], hc[<span class=\"number\">2</span>][<span class=\"number\">0</span>]) * (<span class=\"number\">1.f</span> / hc[<span class=\"number\">3</span>][<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">camera</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//project to z = 0</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">projection</span><span class=\"params\">(<span class=\"type\">const</span> Vec3f &amp;camera)</span> </span>&#123;</span><br><span class=\"line\">    Matrix m = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    m[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"number\">-1.f</span>/camera.z;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//viewport(width / 8, height / 8, width * 0.75, height * 0.75);</span></span><br><span class=\"line\"><span class=\"comment\">//窗口边缘留出1/8空隙</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">viewport</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> w, <span class=\"type\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    Matrix m = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">//Translation</span></span><br><span class=\"line\">    m[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = x + w / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = y + h / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = depth / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    <span class=\"comment\">//scale to [0, 1]</span></span><br><span class=\"line\">    m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = w / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = h / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = depth / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">    Matrix projectionMatrix = <span class=\"built_in\">projection</span>(camera);</span><br><span class=\"line\">    Matrix viewportMatrix = <span class=\"built_in\">viewport</span>(width / <span class=\"number\">8</span>, height / <span class=\"number\">8</span>, width * <span class=\"number\">0.75</span>, height * <span class=\"number\">0.75</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec3f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            <span class=\"comment\">//world -&gt; screen:</span></span><br><span class=\"line\">            <span class=\"comment\">//3d coordinate -&gt; homogeneous coordinates</span></span><br><span class=\"line\">            <span class=\"comment\">//-&gt; projection trans(camera at (0,0,c), project to plane z = 0)</span></span><br><span class=\"line\">            <span class=\"comment\">//-&gt; viewport trans(to make central at (w/2,h/2,d/2))</span></span><br><span class=\"line\"></span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">hc2v</span>(viewportMatrix * projectionMatrix * <span class=\"built_in\">v2hc</span>(v));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Still simplified light intensity</span></span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            Vec2i uv[<span class=\"number\">3</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) uv[j] = model-&gt;<span class=\"built_in\">uv</span>(i, j);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">float</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), uv, image, intensity, zbuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240504160940105-1636523864.png\" alt=\"image-20240504170937200\"></p>\n<p>注：TinyRenderer的透视投影与GAMES101处理方式不同，GAMES101是把M[3][2]固定为1，求解M的第三行，而此处是固定第三行为（0 0 1 0），求解M[3][2]。</p>\n<p>此处并没有“近平面”的概念，认为n&#x3D;0,f&#x3D;c。</p>\n<p>下面是GAMES101给出的结果（第三行为0 0 A B）：</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182227248-1392365094.png\" alt=\"image-20240505192224927\" style=\"zoom:50%;\">\n\n\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182300021-22198105.png\" alt=\"image-20240505192257807\" style=\"zoom:50%;\">\n\n\n\n<h2 id=\"Lesson-5-Moving-the-camera\"><a href=\"#Lesson-5-Moving-the-camera\" class=\"headerlink\" title=\"Lesson 5: Moving the camera\"></a>Lesson 5: Moving the camera</h2><p>之前，我们考虑了相机在(0,0,c)，朝着-z方向看的情况。</p>\n<p>对于任意的相机位置，需要三个向量来确定：相机坐标e，相机指向的点c，向上方向向量u,如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/b94dd4a591514fd66a91a6e4cc065644.png\" alt=\"img\"></p>\n<p>我们假定相机总是朝着-z方向看，而u朝向正y方向，据此就得到了一个新的坐标系x’y’z’，</p>\n<p>下面考虑如何将物体坐标[x,y,z]转化为新坐标系下的[x’,y’,z’]。</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f66a0139058ab1d1025dbfd8cd401389.png\" alt=\"img\"></p>\n<p>首先回顾坐标[x,y,z]的定义，它是三个正交的单位向量i,j,k前面的系数</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f00.png\" alt=\"img\"></p>\n<p>现在，我们有了新的单位向量i’,j’,k’,那么一定存在矩阵M，使得</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f01.png\" alt=\"img\"></p>\n<p>我们将OP写成OO’+O’P,与新的单位坐标建立联系：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f02.png\" alt=\"img\"></p>\n<p>将[i’,j’,k’]用上面的式子表示，提出[i,j,k]:</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f03.png\" alt=\"img\"></p>\n<p>左边用[x,y,z]的定义式替换，就得到了[x’,y’,z’]与[x,y,z]的关系</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f04.png\" alt=\"img\"></p>\n<p>关于look at的推导，此处写的有些混乱<br>建议参阅<a href=\"https://www.zhihu.com/question/447781866\">https://www.zhihu.com/question/447781866</a> </p>\n<p>下面是个人理解：</p>\n<p>简单来说，设M是(0, 0, 0),[i,j,k]到eyepos, [i’,j’,k’]的变换矩阵<br>则M&#x3D;TR,先旋转后平移</p>\n<p>其中旋转矩阵R根据单位向量<strong>左乘</strong>该矩阵得到新单位向量，很容易得到(此处r,u,v是i’,j’,k’在原坐标系下的坐标)</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505210530096-395261047.png\" alt=\"image-20240505220527743\"></p>\n<p>而T则为原点平移到eye pos的平移矩阵 （C是eyepos)</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505211321938-1985120681.png\" alt=\"image-20240505221319762\"></p>\n<p>此为对坐标轴的变换矩阵，即，我们用M计算了<strong>新的单位向量在原坐标系下的坐标</strong>，而要得到原来单位向量在新坐标系下的坐标，显然应该左乘M的逆矩阵。这样，我们就求得了ModelView矩阵。</p>\n<p>据此，编写lookup实现modelview的计算</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vec3f light_dir = <span class=\"built_in\">Vec3f</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">eye</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">center</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">up</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//Vec3f camera(0, 0, 3);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//screen_coordinate = viewport * projection * modelview * world_coordinate</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">lookat</span><span class=\"params\">(Vec3f eye, Vec3f center, Vec3f up)</span> </span>&#123;</span><br><span class=\"line\">    Vec3f z = (eye - center).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">    Vec3f x = (up ^ z).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">    Vec3f y = (z ^ x).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">    Matrix M_inv = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    Matrix T = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">//thanks https://www.zhihu.com/question/447781866</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        M_inv[<span class=\"number\">0</span>][i] = x[i];</span><br><span class=\"line\">        M_inv[<span class=\"number\">1</span>][i] = y[i];</span><br><span class=\"line\">        M_inv[<span class=\"number\">2</span>][i] = z[i];</span><br><span class=\"line\">        T[i][<span class=\"number\">3</span>] = -eye[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> M_inv * T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">projection</span><span class=\"params\">(Vec3f eye, Vec3f center)</span> </span>&#123;</span><br><span class=\"line\">    Matrix m = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    m[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"number\">-1.f</span> / (eye - center).<span class=\"built_in\">norm</span>();</span><br><span class=\"line\">    <span class=\"comment\">//m[3][2] = -1.f / camera.z;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    Matrix modelviewMatrix = <span class=\"built_in\">lookat</span>(eye, center, up);</span><br><span class=\"line\">    Matrix projectionMatrix = <span class=\"built_in\">projection</span>(eye, center);</span><br><span class=\"line\">    Matrix viewportMatrix = <span class=\"built_in\">viewport</span>(width / <span class=\"number\">8</span>, height / <span class=\"number\">8</span>, width * <span class=\"number\">0.75</span>, height * <span class=\"number\">0.75</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    screen_coords[j] = <span class=\"built_in\">hc2v</span>(viewportMatrix * projectionMatrix * modelviewMatrix * <span class=\"built_in\">v2hc</span>(v));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果 目前有点bug</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505215822020-1676545529.png\" alt=\"image-20240505225818988\"></p>\n<h3 id=\"Bouns：Transformation-of-normal-vectors\"><a href=\"#Bouns：Transformation-of-normal-vectors\" class=\"headerlink\" title=\"Bouns：Transformation of normal vectors\"></a>Bouns：Transformation of normal vectors</h3><p>为了处理光照，我们将模型进行坐标变换后，如果模型提供了每个面的法向量，还需要将法向量也进行变换。</p>\n<p>此处有一个结论：模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置。</p>\n<p>证明：考虑平面方程 Ax+By+Cz&#x3D;0，它的法向量是（A,B,C) ,写成矩阵形式为：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f05.png\" alt=\"img\"></p>\n<p>在两者之间插入M的逆和M：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f06.png\" alt=\"img\"></p>\n<p> 由于坐标均为列向量，把左边写成转置形式：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f07.png\" alt=\"img\"></p>\n<p>因此，如果对坐标(x,y,z)做变换M，要满足原来的直线方程，对法向量的变换矩阵为M的逆矩阵的转置（或者转置再求逆，转置和求逆是<strong>可交换的</strong>，证明略）</p>\n<h2 id=\"Lesson-6-Shaders\"><a href=\"#Lesson-6-Shaders\" class=\"headerlink\" title=\"Lesson 6: Shaders\"></a>Lesson 6: Shaders</h2><p>本节主要分为两大部分：重构代码，实现不同的shaders。</p>\n<p>再尝试用自己之前的屎山适配Shader部分后，我放弃了，直接使用作者写的geometry。内容大部分都很直观，值得注意的是</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">size_t</span> LEN,<span class=\"type\">size_t</span> DIM,<span class=\"keyword\">typename</span> T&gt; vec&lt;LEN,T&gt; <span class=\"title\">embed</span><span class=\"params\">(<span class=\"type\">const</span> vec&lt;DIM,T&gt; &amp;v, T fill=<span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    vec&lt;LEN,T&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i=LEN; i--; ret[i]=(i&lt;DIM?v[i]:fill));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">size_t</span> LEN,<span class=\"type\">size_t</span> DIM, <span class=\"keyword\">typename</span> T&gt; vec&lt;LEN,T&gt; <span class=\"title\">proj</span><span class=\"params\">(<span class=\"type\">const</span> vec&lt;DIM,T&gt; &amp;v)</span> </span>&#123;</span><br><span class=\"line\">    vec&lt;LEN,T&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i=LEN; i--; ret[i]=v[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个模板的作用，分别是将低维向量拓展到高维（不足补1）、高维向量投影到低维（截取前LEN个坐标），在涉及其次坐标和普通坐标的转换时多次用到。</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/OpenGL-2.0-Programmable-Shader-Pipeline.png\" alt=\"img\"></p>\n<p>Shader包含顶点着色和片元着色两个部件，将其抽离出来，可以使得我们通过修改Shader即可实现各种不同的渲染效果，而无需改动其他代码。</p>\n<p>在<code>gl.h</code>中，定义Shader的基本结构。不同Shader的通过继承基类重写两个虚函数来实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">IShader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">IShader</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f  <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中，iface是面的编号，而nthvert是顶点编号（对于三角形为0,1,2）。</p>\n<p>例如，一个简单的GouraudShader，vertex通过顶点法向量与光照的点乘计算三角形每个顶点的光照，而fragment通过重心坐标插值计算三角形区域中所有像素的颜色。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GouraudShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    Vec3f varying_intensity;</span><br><span class=\"line\">    <span class=\"comment\">//顶点着色</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        Vec4f glVertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert));</span><br><span class=\"line\">        glVertex = Viewport * Projection * ModelView * glVertex;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        varying_intensity[nthvert] = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, model-&gt;<span class=\"built_in\">normal</span>(iface, nthvert) * light_dir);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> glVertex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//片段着色 用于drawTriangle </span></span><br><span class=\"line\">    <span class=\"comment\">//这里的bar即baryCentric</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = varying_intensity * bar;</span><br><span class=\"line\">        color = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>) * intensity;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//返回值表示是否丢弃</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//in main for every vertex</span></span><br><span class=\"line\">GouraudShader shader;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">    Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">    Vec4f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">        Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">        world_coords[j] = v;</span><br><span class=\"line\">        screen_coords[j] = shader.<span class=\"built_in\">vertex</span>(i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">drawTriangle</span>(screen_coords, shader, image, zbuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// in drawTriangle, for every pixel</span></span><br><span class=\"line\">...</span><br><span class=\"line\">TGAColor color;</span><br><span class=\"line\"><span class=\"type\">bool</span> discard = shader.<span class=\"built_in\">fragment</span>(bc, color);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!discard) &#123;</span><br><span class=\"line\">    zbuffer.<span class=\"built_in\">set</span>(P.x, P.y, <span class=\"built_in\">TGAColor</span>(frag_depth));</span><br><span class=\"line\">    image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>所得的效果如图</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512201920094-1588430460.png\" alt=\"image-20240512211917138\"></p>\n<p>我们可以轻松地修改着色器，实现不同的渲染效果，如将颜色设置为6个梯度的橙色：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> intensity = varying_intensity*bar;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.85</span>) intensity = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.60</span>) intensity = <span class=\"number\">.80</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.45</span>) intensity = <span class=\"number\">.60</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.30</span>) intensity = <span class=\"number\">.45</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.15</span>) intensity = <span class=\"number\">.30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> intensity = <span class=\"number\">0</span>;</span><br><span class=\"line\">    color = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">155</span>, <span class=\"number\">0</span>)*intensity;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202546531-812190877.png\" alt=\"image-20240512212544885\"></p>\n<p><strong>纹理着色器</strong></p>\n<p>接下来，我们可以实现漫反射纹理。只需要修改Shader添加纹理映射项即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TextureShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    Vec3f          varying_intensity; <span class=\"comment\">// written by vertex shader, read by fragment shader</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"type\">float</span>&gt; varying_uv;        <span class=\"comment\">// same as above</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        varying_uv.<span class=\"built_in\">set_col</span>(nthvert, model-&gt;<span class=\"built_in\">uv</span>(iface, nthvert));</span><br><span class=\"line\">        varying_intensity[nthvert] = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, model-&gt;<span class=\"built_in\">normal</span>(iface, nthvert)*light_dir); <span class=\"comment\">// get diffuse lighting intensity</span></span><br><span class=\"line\">        Vec4f gl_Vertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert)); <span class=\"comment\">// read the vertex from .obj file</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class=\"comment\">// transform it to screen coordinates</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = varying_intensity*bar;   <span class=\"comment\">// interpolate intensity for the current pixel</span></span><br><span class=\"line\">        Vec2f uv = varying_uv*bar;                 <span class=\"comment\">// interpolate uv for the current pixel</span></span><br><span class=\"line\">        color = model-&gt;<span class=\"built_in\">diffuse</span>(uv)*intensity;      <span class=\"comment\">// well duh</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;                              <span class=\"comment\">// no, we do not discard this pixel</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202811146-1791754725.png\" alt=\"image-20240512212807641\"></p>\n<p><strong>法线着色器</strong></p>\n<p>事实上，纹理图像中不止可以储存颜色，还可以储存法线方向、温度等等信息。通过纹理给出每个点的法线方向，就能实现表明的凹凸起伏效果。此时，纹理图像的RGB值不再储存颜色，而是用于储存法线，如下图。</p>\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/african_head_nm.png\" alt=\"img\" style=\"zoom:50%;\">\n\n<p>上节课的结尾，我们提到了“模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置”这一结论，根据这个结论，就可以直接在顶点着色器中分别计算顶点和法向量经过投影后的结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NormalShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    mat&lt;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"type\">float</span>&gt; varying_uv;  <span class=\"comment\">// same as above</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_M;   <span class=\"comment\">//  Projection*ModelView</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_MIT; <span class=\"comment\">// (Projection*ModelView).invert_transpose()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        varying_uv.<span class=\"built_in\">set_col</span>(nthvert, model-&gt;<span class=\"built_in\">uv</span>(iface, nthvert));</span><br><span class=\"line\">        Vec4f gl_Vertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert)); <span class=\"comment\">// read the vertex from .obj file</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class=\"comment\">// transform it to screen coordinates</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        Vec2f uv = varying_uv*bar;                 <span class=\"comment\">// interpolate uv for the current pixel</span></span><br><span class=\"line\">        Vec3f n = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_MIT*<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">normal</span>(uv))).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        Vec3f l = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_M  *<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(light_dir        )).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, n*l);</span><br><span class=\"line\">        color = model-&gt;<span class=\"built_in\">diffuse</span>(uv)*intensity;      <span class=\"comment\">// well duh</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;                              <span class=\"comment\">// no, we do not discard this pixel</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512204303617-1448246807.png\" alt=\"image-20240512214259167\"></p>\n<p><strong>Phone模型着色器</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/e3720a5dfedc49edb0bf70f8bc64204a.png\" alt=\"img\"></p>\n<p>根据Phone光照模型，物体的真实光照可以近似为环境光+漫反射+高光。据此，我们可以进一步得出更加真实的着色器。</p>\n<p>高光的计算如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/d58cd3bbab46463e87b782a12a147fbb.png\" alt=\"img\"></p>\n<p>已知物体表明法向量为n，入射光为l，两者夹角为a，假设所有向量都被归一化，设反射光为r，则有l+r&#x3D;2n cosa ，可求得反射光r&#x3D;2n cosa - l &#x3D; 2n(n·l)-l。反射光</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">PhoneShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    mat&lt;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"type\">float</span>&gt; varying_uv;  <span class=\"comment\">// same as above</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_M;   <span class=\"comment\">//  Projection*ModelView</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_MIT; <span class=\"comment\">// (Projection*ModelView).invert_transpose()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        varying_uv.<span class=\"built_in\">set_col</span>(nthvert, model-&gt;<span class=\"built_in\">uv</span>(iface, nthvert));</span><br><span class=\"line\">        Vec4f gl_Vertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert)); <span class=\"comment\">// read the vertex from .obj file</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class=\"comment\">// transform it to screen coordinates</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        Vec2f uv = varying_uv*bar;</span><br><span class=\"line\">        Vec3f n = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_MIT*<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">normal</span>(uv))).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        Vec3f l = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_M  *<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(light_dir        )).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        Vec3f r = (n*(n*l*<span class=\"number\">2.f</span>) - l).<span class=\"built_in\">normalize</span>();   <span class=\"comment\">// reflected light</span></span><br><span class=\"line\">        <span class=\"type\">float</span> spec = <span class=\"built_in\">pow</span>(std::<span class=\"built_in\">max</span>(r.z, <span class=\"number\">0.0f</span>), model-&gt;<span class=\"built_in\">specular</span>(uv));</span><br><span class=\"line\">        <span class=\"type\">float</span> diff = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, n*l);</span><br><span class=\"line\">        TGAColor c = model-&gt;<span class=\"built_in\">diffuse</span>(uv);</span><br><span class=\"line\">        color = c;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) color[i] = std::<span class=\"built_in\">min</span>&lt;<span class=\"type\">float</span>&gt;(<span class=\"number\">5</span> + c[i]*(diff + <span class=\"number\">.6</span>*spec), <span class=\"number\">255</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>按照环境光5+自身颜色*(1漫反射+0.6高光)，得到的效果如下</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512210513789-778169408.png\" alt=\"image-20240512220509696\" style=\"zoom:67%;\">\n\n<p>我们可以试试其他的配比系数，如<code>10 + c[i]*(2 * diff + 1.5*spec</code></p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211926468-1109783721.png\" alt=\"image-20240512221918507\"></p>\n<p>另外，我们还可以到master分支找其他的模型，尝试渲染效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211511558-935691911.png\" alt=\"image-20240512221509093\"></p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512212417887-506051993.png\" alt=\"image-20240512222416047\"></p>\n","excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n\n<h2 id=\"TinyRender学习笔记\"><a href=\"#TinyRender学习笔记\" class=\"headerlink\" title=\"TinyRender学习笔记\"></a>TinyRender学习笔记</h2><p>通过手写软光栅渲染器加深对计算机图形学基本原理的理解，并练习C++面向对象程序设计。</p>\n<p>该项目主要参考<a href=\"https://github.com/ssloy/tinyrenderer/wiki\">Home · ssloy&#x2F;tinyrenderer Wiki (github.com)</a>编写，使用CMake构建</p>\n<p>可以浏览我的历史commit，找到不同进度时提交的代码。</p>\n<p>本项目涉及的几乎所有的图形学知识都在GAMES101课程中出现过，推荐将GAMES101作为前置课程，或配合GAMES101的进度一起学习。</p>\n<h2 id=\"Lesson-0-Getting-Started\"><a href=\"#Lesson-0-Getting-Started\" class=\"headerlink\" title=\"Lesson 0 Getting Started\"></a>Lesson 0 Getting Started</h2><h3 id=\"Using-TGA-image-format\"><a href=\"#Using-TGA-image-format\" class=\"headerlink\" title=\"Using TGA image format\"></a>Using TGA image format</h3><p>使用这个基本框架来生成TGA格式图像：<br><a href=\"https://github.com/ssloy/tinyrenderer/tree/909fe20934ba5334144d2c748805690a1fa4c89f\">ssloy&#x2F;tinyrenderer at 909fe20934ba5334144d2c748805690a1fa4c89f (github.com)</a></p>\n<p>只需 <code>#include &quot;tgaimage.h&quot;</code> ，并在编译时链接tgaimage.cpp即可。</p>\n<p>例：在屏幕上将像素(52,41)设置为红色</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;tgaimage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">//Set color with RGB</span></span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor white = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor red   = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>,   <span class=\"number\">0</span>,   <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//Set image size</span></span><br><span class=\"line\">        <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(<span class=\"number\">100</span>, <span class=\"number\">100</span>, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    \t<span class=\"comment\">//Set pixel color</span></span><br><span class=\"line\">        image.<span class=\"built_in\">set</span>(<span class=\"number\">52</span>, <span class=\"number\">41</span>, red);</span><br><span class=\"line\">        <span class=\"comment\">//To have the origin at the left bottom corner of the image</span></span><br><span class=\"line\">        image.<span class=\"built_in\">flip_vertically</span>(); </span><br><span class=\"line\">        image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>个人推荐的环境：Clion + CMake。（因为VsCode CMake调试功能实在搞不懂&#x3D;.&#x3D;)</p>\n<p>涉及导入模型，需要将工作目录设置为工程文件夹</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220018544-333214793.png\" alt=\"image-20240505230016266\"></p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505220047826-450326712.png\" alt=\"image-20240505230043985\"></p>\n<p>但我的Clion存在tga图像无法加载的bug。在设置-&gt;编辑器-&gt;文件类型中去掉.tga，然后选择用本地程序打开即可。</p>\n<h2 id=\"Lesson-1-Bresenham’s-Line-Drawing-Algorithm\"><a href=\"#Lesson-1-Bresenham’s-Line-Drawing-Algorithm\" class=\"headerlink\" title=\"Lesson 1 Bresenham’s Line Drawing Algorithm\"></a>Lesson 1 Bresenham’s Line Drawing Algorithm</h2><p>使用Bresenham算法绘制线段。</p>\n<p>原理：<a href=\"https://en.wikipedia.org/wiki/Bresenham's_line_algorithm\">https://en.wikipedia.org/wiki/Bresenham&#39;s_line_algorithm</a></p>\n<p>实现参考：<a href=\"https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C++\">https://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm#C++</a></p>\n<p>建议绘制斜率小于-1，-1到0,0到1,大于1，以及水平和垂直的直线来检验算法正确性。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;tgaimage.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor white = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor red = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> TGAColor blue = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">line</span><span class=\"params\">(<span class=\"type\">int</span> x1, <span class=\"type\">int</span> y1, <span class=\"type\">int</span> x2, <span class=\"type\">int</span> y2, TGAImage&amp; image, TGAColor color)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Ensure that slope in (0, 1)</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">bool</span> steep = (std::<span class=\"built_in\">abs</span>(y2 - y1) &gt; std::<span class=\"built_in\">abs</span>(x2 - x1));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (steep) &#123;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(x1, y1);</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(x2, y2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x1 &gt; x2) &#123;</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(x1, x2);</span><br><span class=\"line\">        std::<span class=\"built_in\">swap</span>(y1, y2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">float</span> dx = x2 - x1;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">float</span> dy = <span class=\"built_in\">fabs</span>(y2 - y1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> error = dx / <span class=\"number\">2.0f</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> ystep = (y1 &lt; y2) ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = (<span class=\"type\">int</span>)y1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> maxX = (<span class=\"type\">int</span>)x2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x = (<span class=\"type\">int</span>)x1; x &lt;= maxX; x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (steep) &#123;</span><br><span class=\"line\">            image.<span class=\"built_in\">set</span>(y, x, color);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            image.<span class=\"built_in\">set</span>(x, y, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        error -= dy;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            y += ystep;</span><br><span class=\"line\">            error += dx;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(<span class=\"number\">100</span>, <span class=\"number\">100</span>, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">13</span>, <span class=\"number\">20</span>, <span class=\"number\">80</span>, <span class=\"number\">40</span>, image, red);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">55</span>, <span class=\"number\">33</span>, <span class=\"number\">22</span>, <span class=\"number\">66</span>, image, blue);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">33</span>, <span class=\"number\">33</span>, <span class=\"number\">66</span>, <span class=\"number\">66</span>, image, white);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">44</span>, <span class=\"number\">20</span>, <span class=\"number\">44</span>, <span class=\"number\">80</span>, image, white);</span><br><span class=\"line\">    <span class=\"built_in\">line</span>(<span class=\"number\">20</span>, <span class=\"number\">44</span>, <span class=\"number\">80</span>, <span class=\"number\">44</span>, image, white);</span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419173705372-1981687689.png\" alt=\"image-20240419183705501\"></p>\n<h2 id=\"Lesson-2-Triangle-rasterization-and-back-face-culling\"><a href=\"#Lesson-2-Triangle-rasterization-and-back-face-culling\" class=\"headerlink\" title=\"Lesson 2: Triangle rasterization and back face culling\"></a>Lesson 2: Triangle rasterization and back face culling</h2><p>三维物体模型通常以三角形为基础。为了方便表示点、向量、多边形，写geometry.h。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">Vec2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;t u, v;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;t x, y;&#125;;</span><br><span class=\"line\">        t raw[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">Vec2</span>() : <span class=\"built_in\">u</span>(<span class=\"number\">0</span>), <span class=\"built_in\">v</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Vec2</span>(t _u, t _v) : <span class=\"built_in\">u</span>(_u),<span class=\"built_in\">v</span>(_v) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec2&lt;t&gt; <span class=\"keyword\">operator</span> +(<span class=\"type\">const</span> Vec2&lt;t&gt; &amp;V) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec2</span>&lt;t&gt;(u+V.u, v+V.v); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec2&lt;t&gt; <span class=\"keyword\">operator</span> -(<span class=\"type\">const</span> Vec2&lt;t&gt; &amp;V) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec2</span>&lt;t&gt;(u-V.u, v-V.v); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec2&lt;t&gt; <span class=\"keyword\">operator</span> *(<span class=\"type\">float</span> f)          <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec2</span>&lt;t&gt;(u*f, v*f); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> &gt; <span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec2&lt;t&gt;&amp; v);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; <span class=\"keyword\">struct</span> <span class=\"title class_\">Vec3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;t x, y, z;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123; t ivert, iuv, inorm; &#125;;</span><br><span class=\"line\">        t raw[<span class=\"number\">3</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">Vec3</span>() : <span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">y</span>(<span class=\"number\">0</span>), <span class=\"built_in\">z</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Vec3</span>(t _x, t _y, t _z) : <span class=\"built_in\">x</span>(_x),<span class=\"built_in\">y</span>(_y),<span class=\"built_in\">z</span>(_z) &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> ^(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> +(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(x+v.x, y+v.y, z+v.z); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> -(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(x-v.x, y-v.y, z-v.z); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Vec3&lt;t&gt; <span class=\"keyword\">operator</span> *(<span class=\"type\">float</span> f)          <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3</span>&lt;t&gt;(x*f, y*f, z*f); &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> t       <span class=\"keyword\">operator</span> *(<span class=\"type\">const</span> Vec3&lt;t&gt; &amp;v) <span class=\"type\">const</span> &#123; <span class=\"keyword\">return</span> x*v.x + y*v.y + z*v.z; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">float</span> <span class=\"title\">norm</span> <span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> std::<span class=\"built_in\">sqrt</span>(x*x+y*y+z*z); &#125;</span><br><span class=\"line\">    <span class=\"function\">Vec3&lt;t&gt; &amp; <span class=\"title\">normalize</span><span class=\"params\">(t l=<span class=\"number\">1</span>)</span> </span>&#123; *<span class=\"keyword\">this</span> = (*<span class=\"keyword\">this</span>)*(l/<span class=\"built_in\">norm</span>()); <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> &gt; <span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec3&lt;t&gt;&amp; v);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec2&lt;<span class=\"type\">float</span>&gt; Vec2f;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec2&lt;<span class=\"type\">int</span>&gt;   Vec2i;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec3&lt;<span class=\"type\">float</span>&gt; Vec3f;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Vec3&lt;<span class=\"type\">int</span>&gt;   Vec3i;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec2&lt;t&gt;&amp; v) &#123;</span><br><span class=\"line\">    s &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">t</span>&gt; std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Vec3&lt;t&gt;&amp; v) &#123;</span><br><span class=\"line\">    s &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; v.z &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如何画出实心的三角形？一般来说，有扫描线和边界函数两种算法。</p>\n<p>对于多线程的CPU,采用边界函数法更为高效：先找到三角形的矩形包围盒，再逐点判断是否在三角形中</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">triangle</span>(vec2 points[<span class=\"number\">3</span>]) &#123; </span><br><span class=\"line\">    vec2 bbox[<span class=\"number\">2</span>] = <span class=\"built_in\">find_bounding_box</span>(points); </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (each pixel in the bounding box) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">inside</span>(points, pixel)) &#123; </span><br><span class=\"line\">            <span class=\"built_in\">put_pixel</span>(pixel); </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，问题变成了给定三角形的三个点，如何判断点是否在三角形内部</p>\n<p>一种最好的办法是，计算给定点关于给定三角形的重心坐标（或者叫面积坐标）。</p>\n<p>维基百科：<a href=\"https://zh.wikipedia.org/wiki/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87\">https://zh.wikipedia.org/wiki/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87</a></p>\n<p>简单来说，它表示一个点所对的三条边形成的三角形面积比。如果点在三角形外部，则有一个维度是负的。</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419175823218-1822502417.png\" alt=\"image-20240419185822971\"></p>\n<p>由于tinyrenderer的作者写得有些丑陋，我在geometry.h里直接加入了polygon和triangle类，来实现重心坐标计算和点在三角形内的检测</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Polygon2D</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    std::vector&lt;Vec2&lt;T&gt;&gt; pt;</span><br><span class=\"line\">    <span class=\"built_in\">Polygon2D</span>(<span class=\"type\">int</span> _n, std::vector&lt;Vec2&lt;T&gt;&gt; _pt): <span class=\"built_in\">n</span>(_n), <span class=\"built_in\">pt</span>(_pt) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Triangle2D</span>: <span class=\"keyword\">public</span> Polygon2D&lt;T&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Polygon2D&lt;T&gt;::pt;</span><br><span class=\"line\">    <span class=\"built_in\">Triangle2D</span>(std::vector&lt;Vec2&lt;T&gt;&gt; _pt): <span class=\"built_in\">Polygon2D</span>&lt;T&gt;(<span class=\"number\">3</span>, _pt) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">baryCentric</span><span class=\"params\">(Vec2i P)</span> </span>&#123;</span><br><span class=\"line\">        Vec3f u = <span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>]-P[<span class=\"number\">0</span>])^<span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>]-P[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">/* `pts` and `P` has integer value as coordinates</span></span><br><span class=\"line\"><span class=\"comment\">           so `abs(u[2])` &lt; 1 means `u[2]` is 0, that means</span></span><br><span class=\"line\"><span class=\"comment\">           triangle is degenerate, in this case return something with negative coordinates */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(u.z)&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">inInside</span><span class=\"params\">(Vec2i P)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> bc = <span class=\"built_in\">baryCentric</span>(P);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bc.x&lt;<span class=\"number\">0</span> || bc.y&lt;<span class=\"number\">0</span> || bc.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在main.cpp里绘制实心三角形</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">drawSolidTriangle</span><span class=\"params\">(Triangle2D&lt;<span class=\"type\">int</span>&gt; tri, TGAImage &amp;image, TGAColor color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vec2i <span class=\"title\">bboxmin</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>,  image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2i <span class=\"title\">bboxmax</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2i <span class=\"title\">clamp</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>, image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        bboxmin.x = std::<span class=\"built_in\">max</span>(<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmin.y = std::<span class=\"built_in\">max</span>(<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.y, tri.pt[i].y));</span><br><span class=\"line\"></span><br><span class=\"line\">        bboxmax.x = std::<span class=\"built_in\">min</span>(clamp.x, std::<span class=\"built_in\">max</span>(bboxmax.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmax.y = std::<span class=\"built_in\">min</span>(clamp.y, std::<span class=\"built_in\">max</span>(bboxmax.y, tri.pt[i].y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Vec2i P;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class=\"line\">            Vec3f bc_screen  = tri.<span class=\"built_in\">baryCentric</span>(P);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bc_screen.x&lt;<span class=\"number\">0</span> || bc_screen.y&lt;<span class=\"number\">0</span> || bc_screen.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>得到如图效果：</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419185714797-2050127591.png\" alt=\"image-20240419195714296\" style=\"zoom:50%;\">\n\n<p>三角形绘制完成后，可以尝试导入作者提供的由三角形构成的人脸模型。</p>\n<p>.obj模型文件的格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># List of geometric vertices, with (x, y, z, [w]) coordinates, w is optional and defaults to 1.0.</span><br><span class=\"line\">v 0.123 0.234 0.345 1.0</span><br><span class=\"line\">v ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># List of texture coordinates, in (u, [v, w]) coordinates, these will vary between 0 and 1. v, w are optional and default to 0.</span><br><span class=\"line\">vt 0.500 1 [0]</span><br><span class=\"line\">vt ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># List of vertex normals in (x,y,z) form; normals might not be unit vectors.</span><br><span class=\"line\">vn 0.707 0.000 0.707</span><br><span class=\"line\">vn ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># Parameter space vertices in (u, [v, w]) form; free form geometry statement (see below)</span><br><span class=\"line\">vp 0.310000 3.210000 2.100000</span><br><span class=\"line\">vp ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># Polygonal face element (see below)</span><br><span class=\"line\">f 1 2 3</span><br><span class=\"line\">f 3/1 4/2 5/3</span><br><span class=\"line\">f 6/4/1 3/5/3 7/6/5</span><br><span class=\"line\">f 7//1 8//2 9//3</span><br><span class=\"line\">f ...</span><br><span class=\"line\">...</span><br><span class=\"line\"># Line element (see below)</span><br><span class=\"line\">l 5 8 1 2 4 9</span><br></pre></td></tr></table></figure>\n\n<p>目前，我们暂时不关心模型的深度（z坐标），只是将模型正投影到XY平面上，则模型上的点对应的屏幕坐标可以这样简单的计算</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">screen_coords[j] = <span class=\"built_in\">Vec2i</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>, (v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>);</span><br></pre></td></tr></table></figure>\n\n<p>假设光从正前方射向正后方，即光线方向(0,0,-1)。</p>\n<p>在这里，我们使用一种简化的亮度计算方法：我们忽略面与光源之间的距离差异，认为正对着光源的面（法线与光线方向相同）最亮，这样就可以计算每个三角形面的单位法向量与光线方向的叉积来代表亮度。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span>==argc) &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(<span class=\"string\">&quot;obj/african_head.obj&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(width, height, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec2i screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">Vec2i</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>, (v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>);</span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">int</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), image, <span class=\"built_in\">TGAColor</span>(intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, <span class=\"number\">255</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> model;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种简化下，得到的渲染结果如下：<br><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240419195642124-634629665.png\" alt=\"image-20240419205641217\"></p>\n<p>可以发现，位于口腔中的三角形遮住了嘴唇。下一节课中，我们将考虑深度测试，正确处理多边形的遮挡关系。</p>\n<h2 id=\"Lesson-3-Z-Buffer\"><a href=\"#Lesson-3-Z-Buffer\" class=\"headerlink\" title=\"Lesson 3: Z Buffer\"></a>Lesson 3: Z Buffer</h2><p>深度检测算法的基本原理是，引入一个大小为像素数量的Z-Buffer数组，初始化所有像素点深度为负无穷。</p>\n<p>在遍历像素点时，比较当前三角形上点的深度是否小于Z-Buffer的数值，如果小于，则更新该像素并更新Z-Buffer。</p>\n<p>为此，我们需要为屏幕坐标增加一维深度（对于上面的人脸设置为模型的z即可）。在drawSolidTriangle()中增加对深度缓冲区的判断。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside</span></span><br><span class=\"line\"><span class=\"comment\">// 2024 04 26 2d-&gt;3d</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">drawSolidTriangle</span><span class=\"params\">(Triangle2D&lt;<span class=\"type\">float</span>&gt; tri, TGAImage &amp;image, TGAColor color, <span class=\"type\">float</span> *zbuffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmin</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>,  image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmax</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">clamp</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>, image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        bboxmin.x = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmin.y = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.y, tri.pt[i].y));</span><br><span class=\"line\"></span><br><span class=\"line\">        bboxmax.x = std::<span class=\"built_in\">min</span>(clamp.x, std::<span class=\"built_in\">max</span>(bboxmax.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmax.y = std::<span class=\"built_in\">min</span>(clamp.y, std::<span class=\"built_in\">max</span>(bboxmax.y, tri.pt[i].y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Vec3i P;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class=\"line\">            Vec3f bc_screen  = tri.<span class=\"built_in\">baryCentric</span>(P.<span class=\"built_in\">toVec2</span>());<span class=\"comment\">//toTriangle2D().baryCentric(P);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bc_screen.x&lt;<span class=\"number\">0</span> || bc_screen.y&lt;<span class=\"number\">0</span> || bc_screen.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//bugfix</span></span><br><span class=\"line\">            P.z = tri.depth[<span class=\"number\">0</span>] * bc.x + tri.depth[<span class=\"number\">1</span>] * bc.y + tri.depth[<span class=\"number\">2</span>] * bc.z;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> idx = P.x+P.y*width;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zbuffer[idx]&lt;P.z) &#123;</span><br><span class=\"line\">                zbuffer[idx] = P.z;</span><br><span class=\"line\">                image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">worldToScreen</span><span class=\"params\">(Vec3f v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"built_in\">int</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), <span class=\"built_in\">int</span>((v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), v.z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span>==argc) &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(<span class=\"string\">&quot;obj/african_head.obj&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> *zbuffer = <span class=\"keyword\">new</span> <span class=\"type\">float</span>[width * height];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=width*height; i--; zbuffer[i] = -std::numeric_limits&lt;<span class=\"type\">float</span>&gt;::<span class=\"built_in\">max</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(width, height, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec3f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            <span class=\"comment\">//screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);</span></span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">worldToScreen</span>(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">float</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), image, <span class=\"built_in\">TGAColor</span>(intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, intensity*<span class=\"number\">255</span>, <span class=\"number\">255</span>), zbuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> model;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时，在Triangle2D类中加入depth数组即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Triangle2D</span>: <span class=\"keyword\">public</span> Polygon2D&lt;T&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Polygon2D&lt;T&gt;::pt;</span><br><span class=\"line\">    std::vector&lt;T&gt; depth;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Triangle2D</span>(std::vector&lt;Vec2&lt;T&gt;&gt; _pt, std::vector&lt;Vec2&lt;T&gt;&gt; _depth = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;): </span><br><span class=\"line\">        <span class=\"built_in\">Polygon2D</span>&lt;T&gt;(<span class=\"number\">3</span>, _pt), </span><br><span class=\"line\">        <span class=\"built_in\">depth</span>(_depth) &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"built_in\">Triangle2D</span>(std::vector&lt;Vec3&lt;<span class=\"type\">float</span>&gt;&gt; _pt):</span><br><span class=\"line\">        <span class=\"built_in\">Polygon2D</span>&lt;T&gt;(<span class=\"number\">3</span>, &#123;_pt[<span class=\"number\">0</span>].<span class=\"built_in\">toVec2</span>(), _pt[<span class=\"number\">1</span>].<span class=\"built_in\">toVec2</span>(), _pt[<span class=\"number\">2</span>].<span class=\"built_in\">toVec2</span>()&#125;),</span><br><span class=\"line\">        <span class=\"built_in\">depth</span>(&#123;_pt[<span class=\"number\">0</span>].z, _pt[<span class=\"number\">1</span>].z, _pt[<span class=\"number\">2</span>].z&#125;) &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">baryCentric</span><span class=\"params\">(Vec2f P)</span> </span>&#123;</span><br><span class=\"line\">        Vec3f u = <span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">0</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">0</span>]-P[<span class=\"number\">0</span>])^<span class=\"built_in\">Vec3f</span>(pt[<span class=\"number\">2</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">1</span>][<span class=\"number\">1</span>]-pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>], pt[<span class=\"number\">0</span>][<span class=\"number\">1</span>]-P[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">/* `pts` and `P` has integer value as coordinates</span></span><br><span class=\"line\"><span class=\"comment\">           so `abs(u[2])` &lt; 1 means `u[2]` is 0, that means</span></span><br><span class=\"line\"><span class=\"comment\">           triangle is degenerate, in this case return something with negative coordinates */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (std::<span class=\"built_in\">abs</span>(u.z)&lt;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"number\">1.f</span>-(u.x+u.y)/u.z, u.y/u.z, u.x/u.z);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">inInside</span><span class=\"params\">(Vec2i P)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> bc = <span class=\"built_in\">baryCentric</span>(P);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bc.x&lt;<span class=\"number\">0</span> || bc.y&lt;<span class=\"number\">0</span> || bc.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>效果如图所示：<br><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426165741120-55012551.png\" alt=\"image-20240426175739547\"></p>\n<h3 id=\"Bouns-Texture-Mapping\"><a href=\"#Bouns-Texture-Mapping\" class=\"headerlink\" title=\"Bouns: Texture Mapping\"></a>Bouns: Texture Mapping</h3><p>在.obj文件中，有以“vt u v”开头的行，它们给出了一个纹理坐标数组。 </p>\n<blockquote>\n<p>The number in the middle (between the slashes) in the facet lines “f x&#x2F;x&#x2F;x x&#x2F;x&#x2F;x x&#x2F;x&#x2F;x” are the texture coordinates of this vertex of this triangle. Interpolate it inside the triangle, multiply by the width-height of the texture image and you will get the color to put in your render.</p>\n</blockquote>\n<p>tinyrender作者提供了漫反射纹理： <a href=\"..%5CDownloads%5Cafrican_head_diffuse.tga\">african_head_diffuse.tga</a> </p>\n<p>据此，我们可以给上述人脸模型添加纹理。此时，main函数中drawSolidTriangle函数里不需要再传入颜色，只需要传入intensity即可，另外需要传入当前三角形三个点的纹理坐标uv。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Iterate all points in the rectangular bounding box of triangle, draw if the point is inside</span></span><br><span class=\"line\"><span class=\"comment\">// 2024 04 26 2d-&gt;3d, texture mapping</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">drawSolidTriangle</span><span class=\"params\">(Triangle2D&lt;<span class=\"type\">float</span>&gt; tri, Vec2i* uv, TGAImage &amp;image, <span class=\"type\">float</span> intensity, <span class=\"type\">float</span> *zbuffer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmin</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>,  image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">bboxmax</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec2f <span class=\"title\">clamp</span><span class=\"params\">(image.get_width()<span class=\"number\">-1</span>, image.get_height()<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        bboxmin.x = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmin.y = std::<span class=\"built_in\">max</span>((<span class=\"type\">float</span>)<span class=\"number\">0</span>, std::<span class=\"built_in\">min</span>(bboxmin.y, tri.pt[i].y));</span><br><span class=\"line\"></span><br><span class=\"line\">        bboxmax.x = std::<span class=\"built_in\">min</span>(clamp.x, std::<span class=\"built_in\">max</span>(bboxmax.x, tri.pt[i].x));</span><br><span class=\"line\">        bboxmax.y = std::<span class=\"built_in\">min</span>(clamp.y, std::<span class=\"built_in\">max</span>(bboxmax.y, tri.pt[i].y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Vec3i P;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (P.x=bboxmin.x; P.x&lt;=bboxmax.x; P.x++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (P.y=bboxmin.y; P.y&lt;=bboxmax.y; P.y++) &#123;</span><br><span class=\"line\">            Vec3f bc  = tri.<span class=\"built_in\">baryCentric</span>(P.<span class=\"built_in\">toVec2</span>());<span class=\"comment\">//toTriangle2D().baryCentric(P);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bc.x&lt;<span class=\"number\">0</span> || bc.y&lt;<span class=\"number\">0</span> || bc.z&lt;<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            P.z = tri.depth[<span class=\"number\">0</span>] * bc.x + tri.depth[<span class=\"number\">1</span>] * bc.y + tri.depth[<span class=\"number\">2</span>] * bc.z;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> idx = P.x+P.y*width;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zbuffer[idx]&lt;P.z) &#123;</span><br><span class=\"line\">                zbuffer[idx] = P.z;</span><br><span class=\"line\"></span><br><span class=\"line\">                Vec2i P_uv = uv[<span class=\"number\">0</span>] * bc.x + uv[<span class=\"number\">1</span>] * bc.y + uv[<span class=\"number\">2</span>] * bc.z;</span><br><span class=\"line\">                TGAColor color = model-&gt;<span class=\"built_in\">diffuse</span>(P_uv);</span><br><span class=\"line\">                image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">worldToScreen</span><span class=\"params\">(Vec3f v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(<span class=\"built_in\">int</span>((v.x+<span class=\"number\">1.</span>)*width/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), <span class=\"built_in\">int</span>((v.y+<span class=\"number\">1.</span>)*height/<span class=\"number\">2.</span>+<span class=\"number\">.5</span>), v.z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">2</span>==argc) &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        model = <span class=\"keyword\">new</span> <span class=\"built_in\">Model</span>(<span class=\"string\">&quot;obj/african_head.obj&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">float</span> *zbuffer = <span class=\"keyword\">new</span> <span class=\"type\">float</span>[width * height];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=width*height; i--; zbuffer[i] = -std::numeric_limits&lt;<span class=\"type\">float</span>&gt;::<span class=\"built_in\">max</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TGAImage <span class=\"title\">image</span><span class=\"params\">(width, height, TGAImage::RGB)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec3f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            <span class=\"comment\">//screen_coords[j] = Vec2i((v.x+1.)*width/2., (v.y+1.)*height/2.);</span></span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">worldToScreen</span>(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            Vec2i uv[<span class=\"number\">3</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) uv[j] = model-&gt;<span class=\"built_in\">uv</span>(i, j);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">float</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), uv, image, intensity, zbuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    image.<span class=\"built_in\">flip_vertically</span>();</span><br><span class=\"line\">    image.<span class=\"built_in\">write_tga_file</span>(<span class=\"string\">&quot;output.tga&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> model;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>model.h和model.cpp需要修改以支持纹理。作者在lesson4的结尾放出了代码。</p>\n<p>效果：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202404/1928276-20240426180250012-1899969424.png\" alt=\"image-20240426190246539\"></p>\n<p>这是一个平行投影的结果，损失了一部分真实感，例如，虽然耳朵旁边的头发在xoy平面上不与脸部重叠，但实际上应该被前边的皮肤遮挡，因为人眼&#x2F;相机本身是“点光源”，而不是“平行光源”，物体发出的光线最终汇聚于一点，也就是所谓的“透视”。下面将引入透视投影：</p>\n<h2 id=\"Lesson-4-Perspective-projection\"><a href=\"#Lesson-4-Perspective-projection\" class=\"headerlink\" title=\"Lesson 4: Perspective projection\"></a>Lesson 4: Perspective projection</h2><p>齐次坐标</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f10.png\" alt=\"img\"></p>\n<p>简单变换（图来自GAMES101）</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505164930200-682100308.png\" alt=\"image-20240505174927834\"></p>\n<p>逆变换</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165458526-1584226714.png\" alt=\"image-20240505175454080\"></p>\n<p>复合变换</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505165021790-531013206.png\" alt=\"image-20240505175019922\"></p>\n<p>实现矩阵类：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> DEFAULT_D = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Matrix</span> &#123;</span><br><span class=\"line\">    std::vector&lt;std::vector&lt;<span class=\"type\">float</span>&gt;&gt; m;</span><br><span class=\"line\">    <span class=\"type\">int</span> nrow, ncol;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Matrix</span>(<span class=\"type\">int</span> r=DEFAULT_D, <span class=\"type\">int</span> c=DEFAULT_D) :</span><br><span class=\"line\">        <span class=\"built_in\">m</span>(std::vector&lt;std::vector&lt;<span class=\"type\">float</span>&gt;&gt; (r, std::<span class=\"built_in\">vector</span>&lt;<span class=\"type\">float</span>&gt;(c, <span class=\"number\">0.f</span>))),</span><br><span class=\"line\">        <span class=\"built_in\">nrow</span>(r), <span class=\"built_in\">ncol</span>(c) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_nrow</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> nrow; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_ncol</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> ncol; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> Matrix <span class=\"title\">identity</span><span class=\"params\">(<span class=\"type\">int</span> dimensions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">E</span><span class=\"params\">(dimensions, dimensions)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; dimensions; i++)</span><br><span class=\"line\">            E[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> E;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">float</span>&gt;&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">const</span> <span class=\"type\">int</span> i) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt; nrow);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> std::vector&lt;<span class=\"type\">float</span>&gt;&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">const</span> <span class=\"type\">int</span> i) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(i &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt; nrow);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Matrix <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Matrix&amp; a) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(<span class=\"keyword\">this</span>-&gt;ncol == a.nrow);</span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">res</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;nrow, a.ncol)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>-&gt;nrow; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; a.ncol; j++) &#123;</span><br><span class=\"line\">                res.m[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"keyword\">this</span>-&gt;ncol; k++)</span><br><span class=\"line\">                    res.m[i][j] += <span class=\"keyword\">this</span>-&gt;m[i][k]*a.m[k][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Matrix <span class=\"title\">transpose</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">res</span><span class=\"params\">(ncol, nrow)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ncol; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; nrow; j++)</span><br><span class=\"line\">                res.m[i][j] = m[j][i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">Matrix <span class=\"title\">inverse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">assert</span>(nrow==ncol);</span><br><span class=\"line\">        <span class=\"comment\">// augmenting the square matrix with the identity matrix of the same dimensions a =&gt; [ai]</span></span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">result</span><span class=\"params\">(nrow, ncol*<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;ncol; j++)</span><br><span class=\"line\">                result[i][j] = m[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow; i++)</span><br><span class=\"line\">            result[i][i+ncol] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// first pass</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow<span class=\"number\">-1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// normalize the first row</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=result.ncol<span class=\"number\">-1</span>; j&gt;=<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">                result[i][j] /= result[i][i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=i+<span class=\"number\">1</span>; k&lt;nrow; k++) &#123;</span><br><span class=\"line\">                <span class=\"type\">float</span> coeff = result[k][i];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;result.ncol; j++) &#123;</span><br><span class=\"line\">                    result[k][j] -= result[i][j]*coeff;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// normalize the last row</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=result.ncol<span class=\"number\">-1</span>; j&gt;=nrow<span class=\"number\">-1</span>; j--)</span><br><span class=\"line\">            result[nrow<span class=\"number\">-1</span>][j] /= result[nrow<span class=\"number\">-1</span>][nrow<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"comment\">// second pass</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=nrow<span class=\"number\">-1</span>; i&gt;<span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=i<span class=\"number\">-1</span>; k&gt;=<span class=\"number\">0</span>; k--) &#123;</span><br><span class=\"line\">                <span class=\"type\">float</span> coeff = result[k][i];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;result.ncol; j++) &#123;</span><br><span class=\"line\">                    result[k][j] -= result[i][j]*coeff;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// cut the identity matrix back</span></span><br><span class=\"line\">        <span class=\"function\">Matrix <span class=\"title\">truncate</span><span class=\"params\">(nrow, ncol)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nrow; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;ncol; j++)</span><br><span class=\"line\">                truncate[i][j] = result[i][j+ncol];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> truncate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Matrix&amp; m);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp; s, Matrix&amp; m) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m.nrow; i++)  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m.ncol; j++) &#123;</span><br><span class=\"line\">            s &lt;&lt; m[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j&lt;m.ncol<span class=\"number\">-1</span>) s &lt;&lt; <span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>一个简单投影矩阵的推导：</p>\n<p>假设相机位置为（0,0,c）成像平面为z&#x3D;0，如图</p>\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/525d3930435c3be900e4c7956edb5a1c.png\" alt=\"img\" style=\"zoom: 67%;\">\n\n\n\n<p>根据三角形相似，x’&#x2F;c &#x3D; x&#x2F;(c-z)，即有</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f15.png\" alt=\"img\"></p>\n<p>同理</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f16.png\" alt=\"img\"></p>\n<p>为了实现z轴方向上靠近相机的线段被拉伸，远离相机的线段被压缩，投影矩阵具有这样的形式</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f13.png\" alt=\"img\"></p>\n<p>根据齐次坐标的结果，得到对应的投影点坐标</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f14.png\" alt=\"img\"></p>\n<p>根据上面的结果，可知r&#x3D;-1&#x2F;c。</p>\n<p>我们可以得到一个简单情况下的投影矩阵，变换过程如图</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/04-perspective-projection/f17.png\" alt=\"img\"></p>\n<p>在程序中，这个过程用如下方式实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">screen_coords[j] = <span class=\"built_in\">hc2v</span>(viewportMatrix * projectionMatrix * <span class=\"built_in\">v2hc</span>(v));</span><br></pre></td></tr></table></figure>\n\n<p>(普通坐标 → 齐次坐标)</p>\n<p>世界坐标 → (经投影变换)投影坐标 → （经视口变换)屏幕坐标 </p>\n<p>(齐次坐标 → 普通坐标)</p>\n<p>这里的坐标包含位置(x,y)和深度z,深度交给z-buffer来处理</p>\n<p>视口变化的目的是将投影区域映射到[-1,1]^3的立方体中，便于绘制</p>\n<p>相关变化的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Transition between coordinates (vector type) and homogeneous coordinates (matrix type)</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">v2hc</span><span class=\"params\">(<span class=\"type\">const</span> Vec3f &amp;v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Matrix <span class=\"title\">hc</span><span class=\"params\">(<span class=\"number\">4</span>, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    hc[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = v.x;</span><br><span class=\"line\">    hc[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = v.y;</span><br><span class=\"line\">    hc[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = v.z;</span><br><span class=\"line\">    hc[<span class=\"number\">3</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">hc2v</span><span class=\"params\">(<span class=\"type\">const</span> Matrix &amp;hc)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Vec3f</span>(hc[<span class=\"number\">0</span>][<span class=\"number\">0</span>], hc[<span class=\"number\">1</span>][<span class=\"number\">0</span>], hc[<span class=\"number\">2</span>][<span class=\"number\">0</span>]) * (<span class=\"number\">1.f</span> / hc[<span class=\"number\">3</span>][<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">light_dir</span><span class=\"params\">(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">camera</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//project to z = 0</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">projection</span><span class=\"params\">(<span class=\"type\">const</span> Vec3f &amp;camera)</span> </span>&#123;</span><br><span class=\"line\">    Matrix m = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    m[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"number\">-1.f</span>/camera.z;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//viewport(width / 8, height / 8, width * 0.75, height * 0.75);</span></span><br><span class=\"line\"><span class=\"comment\">//窗口边缘留出1/8空隙</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">viewport</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> w, <span class=\"type\">int</span> h)</span> </span>&#123;</span><br><span class=\"line\">    Matrix m = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">//Translation</span></span><br><span class=\"line\">    m[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = x + w / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">1</span>][<span class=\"number\">3</span>] = y + h / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">2</span>][<span class=\"number\">3</span>] = depth / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    <span class=\"comment\">//scale to [0, 1]</span></span><br><span class=\"line\">    m[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = w / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = h / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    m[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = depth / <span class=\"number\">2.f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">    Matrix projectionMatrix = <span class=\"built_in\">projection</span>(camera);</span><br><span class=\"line\">    Matrix viewportMatrix = <span class=\"built_in\">viewport</span>(width / <span class=\"number\">8</span>, height / <span class=\"number\">8</span>, width * <span class=\"number\">0.75</span>, height * <span class=\"number\">0.75</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">        std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">        Vec3f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">            Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">            <span class=\"comment\">//world -&gt; screen:</span></span><br><span class=\"line\">            <span class=\"comment\">//3d coordinate -&gt; homogeneous coordinates</span></span><br><span class=\"line\">            <span class=\"comment\">//-&gt; projection trans(camera at (0,0,c), project to plane z = 0)</span></span><br><span class=\"line\">            <span class=\"comment\">//-&gt; viewport trans(to make central at (w/2,h/2,d/2))</span></span><br><span class=\"line\"></span><br><span class=\"line\">            world_coords[j]  = v;</span><br><span class=\"line\">            screen_coords[j] = <span class=\"built_in\">hc2v</span>(viewportMatrix * projectionMatrix * <span class=\"built_in\">v2hc</span>(v));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//Still simplified light intensity</span></span><br><span class=\"line\">        Vec3f n = (world_coords[<span class=\"number\">2</span>]-world_coords[<span class=\"number\">0</span>])^(world_coords[<span class=\"number\">1</span>]-world_coords[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        n.<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = n*light_dir;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ok %d\\n&quot;</span>, ++cnt);</span><br><span class=\"line\">            Vec2i uv[<span class=\"number\">3</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) uv[j] = model-&gt;<span class=\"built_in\">uv</span>(i, j);</span><br><span class=\"line\">            <span class=\"built_in\">drawSolidTriangle</span>(<span class=\"built_in\">Triangle2D</span>&lt;<span class=\"type\">float</span>&gt;(&#123;screen_coords[<span class=\"number\">0</span>], screen_coords[<span class=\"number\">1</span>], screen_coords[<span class=\"number\">2</span>]&#125;), uv, image, intensity, zbuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240504160940105-1636523864.png\" alt=\"image-20240504170937200\"></p>\n<p>注：TinyRenderer的透视投影与GAMES101处理方式不同，GAMES101是把M[3][2]固定为1，求解M的第三行，而此处是固定第三行为（0 0 1 0），求解M[3][2]。</p>\n<p>此处并没有“近平面”的概念，认为n&#x3D;0,f&#x3D;c。</p>\n<p>下面是GAMES101给出的结果（第三行为0 0 A B）：</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182227248-1392365094.png\" alt=\"image-20240505192224927\" style=\"zoom:50%;\">\n\n\n\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505182300021-22198105.png\" alt=\"image-20240505192257807\" style=\"zoom:50%;\">\n\n\n\n<h2 id=\"Lesson-5-Moving-the-camera\"><a href=\"#Lesson-5-Moving-the-camera\" class=\"headerlink\" title=\"Lesson 5: Moving the camera\"></a>Lesson 5: Moving the camera</h2><p>之前，我们考虑了相机在(0,0,c)，朝着-z方向看的情况。</p>\n<p>对于任意的相机位置，需要三个向量来确定：相机坐标e，相机指向的点c，向上方向向量u,如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/b94dd4a591514fd66a91a6e4cc065644.png\" alt=\"img\"></p>\n<p>我们假定相机总是朝着-z方向看，而u朝向正y方向，据此就得到了一个新的坐标系x’y’z’，</p>\n<p>下面考虑如何将物体坐标[x,y,z]转化为新坐标系下的[x’,y’,z’]。</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f66a0139058ab1d1025dbfd8cd401389.png\" alt=\"img\"></p>\n<p>首先回顾坐标[x,y,z]的定义，它是三个正交的单位向量i,j,k前面的系数</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f00.png\" alt=\"img\"></p>\n<p>现在，我们有了新的单位向量i’,j’,k’,那么一定存在矩阵M，使得</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f01.png\" alt=\"img\"></p>\n<p>我们将OP写成OO’+O’P,与新的单位坐标建立联系：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f02.png\" alt=\"img\"></p>\n<p>将[i’,j’,k’]用上面的式子表示，提出[i,j,k]:</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f03.png\" alt=\"img\"></p>\n<p>左边用[x,y,z]的定义式替换，就得到了[x’,y’,z’]与[x,y,z]的关系</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f04.png\" alt=\"img\"></p>\n<p>关于look at的推导，此处写的有些混乱<br>建议参阅<a href=\"https://www.zhihu.com/question/447781866\">https://www.zhihu.com/question/447781866</a> </p>\n<p>下面是个人理解：</p>\n<p>简单来说，设M是(0, 0, 0),[i,j,k]到eyepos, [i’,j’,k’]的变换矩阵<br>则M&#x3D;TR,先旋转后平移</p>\n<p>其中旋转矩阵R根据单位向量<strong>左乘</strong>该矩阵得到新单位向量，很容易得到(此处r,u,v是i’,j’,k’在原坐标系下的坐标)</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505210530096-395261047.png\" alt=\"image-20240505220527743\"></p>\n<p>而T则为原点平移到eye pos的平移矩阵 （C是eyepos)</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505211321938-1985120681.png\" alt=\"image-20240505221319762\"></p>\n<p>此为对坐标轴的变换矩阵，即，我们用M计算了<strong>新的单位向量在原坐标系下的坐标</strong>，而要得到原来单位向量在新坐标系下的坐标，显然应该左乘M的逆矩阵。这样，我们就求得了ModelView矩阵。</p>\n<p>据此，编写lookup实现modelview的计算</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vec3f light_dir = <span class=\"built_in\">Vec3f</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">eye</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">center</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vec3f <span class=\"title\">up</span><span class=\"params\">(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//Vec3f camera(0, 0, 3);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//screen_coordinate = viewport * projection * modelview * world_coordinate</span></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">lookat</span><span class=\"params\">(Vec3f eye, Vec3f center, Vec3f up)</span> </span>&#123;</span><br><span class=\"line\">    Vec3f z = (eye - center).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">    Vec3f x = (up ^ z).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">    Vec3f y = (z ^ x).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">    Matrix M_inv = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    Matrix T = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">//thanks https://www.zhihu.com/question/447781866</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        M_inv[<span class=\"number\">0</span>][i] = x[i];</span><br><span class=\"line\">        M_inv[<span class=\"number\">1</span>][i] = y[i];</span><br><span class=\"line\">        M_inv[<span class=\"number\">2</span>][i] = z[i];</span><br><span class=\"line\">        T[i][<span class=\"number\">3</span>] = -eye[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> M_inv * T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Matrix <span class=\"title\">projection</span><span class=\"params\">(Vec3f eye, Vec3f center)</span> </span>&#123;</span><br><span class=\"line\">    Matrix m = Matrix::<span class=\"built_in\">identity</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    m[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"number\">-1.f</span> / (eye - center).<span class=\"built_in\">norm</span>();</span><br><span class=\"line\">    <span class=\"comment\">//m[3][2] = -1.f / camera.z;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    Matrix modelviewMatrix = <span class=\"built_in\">lookat</span>(eye, center, up);</span><br><span class=\"line\">    Matrix projectionMatrix = <span class=\"built_in\">projection</span>(eye, center);</span><br><span class=\"line\">    Matrix viewportMatrix = <span class=\"built_in\">viewport</span>(width / <span class=\"number\">8</span>, height / <span class=\"number\">8</span>, width * <span class=\"number\">0.75</span>, height * <span class=\"number\">0.75</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    screen_coords[j] = <span class=\"built_in\">hc2v</span>(viewportMatrix * projectionMatrix * modelviewMatrix * <span class=\"built_in\">v2hc</span>(v));</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果 目前有点bug</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240505215822020-1676545529.png\" alt=\"image-20240505225818988\"></p>\n<h3 id=\"Bouns：Transformation-of-normal-vectors\"><a href=\"#Bouns：Transformation-of-normal-vectors\" class=\"headerlink\" title=\"Bouns：Transformation of normal vectors\"></a>Bouns：Transformation of normal vectors</h3><p>为了处理光照，我们将模型进行坐标变换后，如果模型提供了每个面的法向量，还需要将法向量也进行变换。</p>\n<p>此处有一个结论：模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置。</p>\n<p>证明：考虑平面方程 Ax+By+Cz&#x3D;0，它的法向量是（A,B,C) ,写成矩阵形式为：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f05.png\" alt=\"img\"></p>\n<p>在两者之间插入M的逆和M：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f06.png\" alt=\"img\"></p>\n<p> 由于坐标均为列向量，把左边写成转置形式：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/05-camera/f07.png\" alt=\"img\"></p>\n<p>因此，如果对坐标(x,y,z)做变换M，要满足原来的直线方程，对法向量的变换矩阵为M的逆矩阵的转置（或者转置再求逆，转置和求逆是<strong>可交换的</strong>，证明略）</p>\n<h2 id=\"Lesson-6-Shaders\"><a href=\"#Lesson-6-Shaders\" class=\"headerlink\" title=\"Lesson 6: Shaders\"></a>Lesson 6: Shaders</h2><p>本节主要分为两大部分：重构代码，实现不同的shaders。</p>\n<p>再尝试用自己之前的屎山适配Shader部分后，我放弃了，直接使用作者写的geometry。内容大部分都很直观，值得注意的是</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">size_t</span> LEN,<span class=\"type\">size_t</span> DIM,<span class=\"keyword\">typename</span> T&gt; vec&lt;LEN,T&gt; <span class=\"title\">embed</span><span class=\"params\">(<span class=\"type\">const</span> vec&lt;DIM,T&gt; &amp;v, T fill=<span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    vec&lt;LEN,T&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i=LEN; i--; ret[i]=(i&lt;DIM?v[i]:fill));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"type\">size_t</span> LEN,<span class=\"type\">size_t</span> DIM, <span class=\"keyword\">typename</span> T&gt; vec&lt;LEN,T&gt; <span class=\"title\">proj</span><span class=\"params\">(<span class=\"type\">const</span> vec&lt;DIM,T&gt; &amp;v)</span> </span>&#123;</span><br><span class=\"line\">    vec&lt;LEN,T&gt; ret;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i=LEN; i--; ret[i]=v[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个模板的作用，分别是将低维向量拓展到高维（不足补1）、高维向量投影到低维（截取前LEN个坐标），在涉及其次坐标和普通坐标的转换时多次用到。</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/OpenGL-2.0-Programmable-Shader-Pipeline.png\" alt=\"img\"></p>\n<p>Shader包含顶点着色和片元着色两个部件，将其抽离出来，可以使得我们通过修改Shader即可实现各种不同的渲染效果，而无需改动其他代码。</p>\n<p>在<code>gl.h</code>中，定义Shader的基本结构。不同Shader的通过继承基类重写两个虚函数来实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">IShader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">IShader</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f  <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中，iface是面的编号，而nthvert是顶点编号（对于三角形为0,1,2）。</p>\n<p>例如，一个简单的GouraudShader，vertex通过顶点法向量与光照的点乘计算三角形每个顶点的光照，而fragment通过重心坐标插值计算三角形区域中所有像素的颜色。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">GouraudShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    Vec3f varying_intensity;</span><br><span class=\"line\">    <span class=\"comment\">//顶点着色</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        Vec4f glVertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert));</span><br><span class=\"line\">        glVertex = Viewport * Projection * ModelView * glVertex;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        varying_intensity[nthvert] = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, model-&gt;<span class=\"built_in\">normal</span>(iface, nthvert) * light_dir);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> glVertex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//片段着色 用于drawTriangle </span></span><br><span class=\"line\">    <span class=\"comment\">//这里的bar即baryCentric</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = varying_intensity * bar;</span><br><span class=\"line\">        color = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">255</span>, <span class=\"number\">255</span>) * intensity;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;\t<span class=\"comment\">//返回值表示是否丢弃</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//in main for every vertex</span></span><br><span class=\"line\">GouraudShader shader;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;model-&gt;<span class=\"built_in\">nfaces</span>(); i++) &#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; face = model-&gt;<span class=\"built_in\">face</span>(i);</span><br><span class=\"line\">    Vec3f world_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">    Vec4f screen_coords[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">        Vec3f v = model-&gt;<span class=\"built_in\">vert</span>(face[j]);</span><br><span class=\"line\">        world_coords[j] = v;</span><br><span class=\"line\">        screen_coords[j] = shader.<span class=\"built_in\">vertex</span>(i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">drawTriangle</span>(screen_coords, shader, image, zbuffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// in drawTriangle, for every pixel</span></span><br><span class=\"line\">...</span><br><span class=\"line\">TGAColor color;</span><br><span class=\"line\"><span class=\"type\">bool</span> discard = shader.<span class=\"built_in\">fragment</span>(bc, color);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!discard) &#123;</span><br><span class=\"line\">    zbuffer.<span class=\"built_in\">set</span>(P.x, P.y, <span class=\"built_in\">TGAColor</span>(frag_depth));</span><br><span class=\"line\">    image.<span class=\"built_in\">set</span>(P.x, P.y, color);</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>所得的效果如图</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512201920094-1588430460.png\" alt=\"image-20240512211917138\"></p>\n<p>我们可以轻松地修改着色器，实现不同的渲染效果，如将颜色设置为6个梯度的橙色：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> intensity = varying_intensity*bar;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.85</span>) intensity = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.60</span>) intensity = <span class=\"number\">.80</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.45</span>) intensity = <span class=\"number\">.60</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.30</span>) intensity = <span class=\"number\">.45</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (intensity&gt;<span class=\"number\">.15</span>) intensity = <span class=\"number\">.30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> intensity = <span class=\"number\">0</span>;</span><br><span class=\"line\">    color = <span class=\"built_in\">TGAColor</span>(<span class=\"number\">255</span>, <span class=\"number\">155</span>, <span class=\"number\">0</span>)*intensity;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202546531-812190877.png\" alt=\"image-20240512212544885\"></p>\n<p><strong>纹理着色器</strong></p>\n<p>接下来，我们可以实现漫反射纹理。只需要修改Shader添加纹理映射项即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TextureShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    Vec3f          varying_intensity; <span class=\"comment\">// written by vertex shader, read by fragment shader</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"type\">float</span>&gt; varying_uv;        <span class=\"comment\">// same as above</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        varying_uv.<span class=\"built_in\">set_col</span>(nthvert, model-&gt;<span class=\"built_in\">uv</span>(iface, nthvert));</span><br><span class=\"line\">        varying_intensity[nthvert] = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, model-&gt;<span class=\"built_in\">normal</span>(iface, nthvert)*light_dir); <span class=\"comment\">// get diffuse lighting intensity</span></span><br><span class=\"line\">        Vec4f gl_Vertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert)); <span class=\"comment\">// read the vertex from .obj file</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class=\"comment\">// transform it to screen coordinates</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = varying_intensity*bar;   <span class=\"comment\">// interpolate intensity for the current pixel</span></span><br><span class=\"line\">        Vec2f uv = varying_uv*bar;                 <span class=\"comment\">// interpolate uv for the current pixel</span></span><br><span class=\"line\">        color = model-&gt;<span class=\"built_in\">diffuse</span>(uv)*intensity;      <span class=\"comment\">// well duh</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;                              <span class=\"comment\">// no, we do not discard this pixel</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512202811146-1791754725.png\" alt=\"image-20240512212807641\"></p>\n<p><strong>法线着色器</strong></p>\n<p>事实上，纹理图像中不止可以储存颜色，还可以储存法线方向、温度等等信息。通过纹理给出每个点的法线方向，就能实现表明的凹凸起伏效果。此时，纹理图像的RGB值不再储存颜色，而是用于储存法线，如下图。</p>\n<img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/african_head_nm.png\" alt=\"img\" style=\"zoom:50%;\">\n\n<p>上节课的结尾，我们提到了“模型上的坐标通过矩阵M进行仿射变换，那么模型的法向量的变换矩阵是M的逆矩阵的转置”这一结论，根据这个结论，就可以直接在顶点着色器中分别计算顶点和法向量经过投影后的结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">NormalShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    mat&lt;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"type\">float</span>&gt; varying_uv;  <span class=\"comment\">// same as above</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_M;   <span class=\"comment\">//  Projection*ModelView</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_MIT; <span class=\"comment\">// (Projection*ModelView).invert_transpose()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        varying_uv.<span class=\"built_in\">set_col</span>(nthvert, model-&gt;<span class=\"built_in\">uv</span>(iface, nthvert));</span><br><span class=\"line\">        Vec4f gl_Vertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert)); <span class=\"comment\">// read the vertex from .obj file</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class=\"comment\">// transform it to screen coordinates</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        Vec2f uv = varying_uv*bar;                 <span class=\"comment\">// interpolate uv for the current pixel</span></span><br><span class=\"line\">        Vec3f n = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_MIT*<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">normal</span>(uv))).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        Vec3f l = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_M  *<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(light_dir        )).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        <span class=\"type\">float</span> intensity = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, n*l);</span><br><span class=\"line\">        color = model-&gt;<span class=\"built_in\">diffuse</span>(uv)*intensity;      <span class=\"comment\">// well duh</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;                              <span class=\"comment\">// no, we do not discard this pixel</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>效果：</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512204303617-1448246807.png\" alt=\"image-20240512214259167\"></p>\n<p><strong>Phone模型着色器</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/e3720a5dfedc49edb0bf70f8bc64204a.png\" alt=\"img\"></p>\n<p>根据Phone光照模型，物体的真实光照可以近似为环境光+漫反射+高光。据此，我们可以进一步得出更加真实的着色器。</p>\n<p>高光的计算如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/ssloy/tinyrenderer/gh-pages/img/06-shaders/d58cd3bbab46463e87b782a12a147fbb.png\" alt=\"img\"></p>\n<p>已知物体表明法向量为n，入射光为l，两者夹角为a，假设所有向量都被归一化，设反射光为r，则有l+r&#x3D;2n cosa ，可求得反射光r&#x3D;2n cosa - l &#x3D; 2n(n·l)-l。反射光</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">PhoneShader</span> : <span class=\"keyword\">public</span> IShader &#123;</span><br><span class=\"line\">    mat&lt;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"type\">float</span>&gt; varying_uv;  <span class=\"comment\">// same as above</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_M;   <span class=\"comment\">//  Projection*ModelView</span></span><br><span class=\"line\">    mat&lt;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"type\">float</span>&gt; uniform_MIT; <span class=\"comment\">// (Projection*ModelView).invert_transpose()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Vec4f <span class=\"title\">vertex</span><span class=\"params\">(<span class=\"type\">int</span> iface, <span class=\"type\">int</span> nthvert)</span> </span>&#123;</span><br><span class=\"line\">        varying_uv.<span class=\"built_in\">set_col</span>(nthvert, model-&gt;<span class=\"built_in\">uv</span>(iface, nthvert));</span><br><span class=\"line\">        Vec4f gl_Vertex = <span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">vert</span>(iface, nthvert)); <span class=\"comment\">// read the vertex from .obj file</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Viewport*Projection*ModelView*gl_Vertex; <span class=\"comment\">// transform it to screen coordinates</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">fragment</span><span class=\"params\">(Vec3f bar, TGAColor &amp;color)</span> </span>&#123;</span><br><span class=\"line\">        Vec2f uv = varying_uv*bar;</span><br><span class=\"line\">        Vec3f n = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_MIT*<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(model-&gt;<span class=\"built_in\">normal</span>(uv))).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        Vec3f l = <span class=\"built_in\">proj</span>&lt;<span class=\"number\">3</span>&gt;(uniform_M  *<span class=\"built_in\">embed</span>&lt;<span class=\"number\">4</span>&gt;(light_dir        )).<span class=\"built_in\">normalize</span>();</span><br><span class=\"line\">        Vec3f r = (n*(n*l*<span class=\"number\">2.f</span>) - l).<span class=\"built_in\">normalize</span>();   <span class=\"comment\">// reflected light</span></span><br><span class=\"line\">        <span class=\"type\">float</span> spec = <span class=\"built_in\">pow</span>(std::<span class=\"built_in\">max</span>(r.z, <span class=\"number\">0.0f</span>), model-&gt;<span class=\"built_in\">specular</span>(uv));</span><br><span class=\"line\">        <span class=\"type\">float</span> diff = std::<span class=\"built_in\">max</span>(<span class=\"number\">0.f</span>, n*l);</span><br><span class=\"line\">        TGAColor c = model-&gt;<span class=\"built_in\">diffuse</span>(uv);</span><br><span class=\"line\">        color = c;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">3</span>; i++) color[i] = std::<span class=\"built_in\">min</span>&lt;<span class=\"type\">float</span>&gt;(<span class=\"number\">5</span> + c[i]*(diff + <span class=\"number\">.6</span>*spec), <span class=\"number\">255</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>按照环境光5+自身颜色*(1漫反射+0.6高光)，得到的效果如下</p>\n<img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512210513789-778169408.png\" alt=\"image-20240512220509696\" style=\"zoom:67%;\">\n\n<p>我们可以试试其他的配比系数，如<code>10 + c[i]*(2 * diff + 1.5*spec</code></p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211926468-1109783721.png\" alt=\"image-20240512221918507\"></p>\n<p>另外，我们还可以到master分支找其他的模型，尝试渲染效果</p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512211511558-935691911.png\" alt=\"image-20240512221509093\"></p>\n<p><img src=\"https://img2023.cnblogs.com/blog/1928276/202405/1928276-20240512212417887-506051993.png\" alt=\"image-20240512222416047\"></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2025-08-26T06:13:21.746Z","updated":"2025-08-26T06:13:21.746Z","comments":1,"layout":"post","photos":[],"_id":"cmes8p36d0007lkw9dgw08vtf","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"test","date":"2025-07-14T06:17:04.000Z","_content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\ntest uploading a pic in cnblogs\n\n![image-20250714144612388](https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145620944-648175100.png)\n\n![image-20250714145658002](https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145728019-230657612.png)\n","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2025-07-14 14:17:04\ntags:\n---\n\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\ntest uploading a pic in cnblogs\n\n![image-20250714144612388](https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145620944-648175100.png)\n\n![image-20250714145658002](https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145728019-230657612.png)\n","slug":"test","published":1,"updated":"2025-08-26T06:13:21.750Z","comments":1,"layout":"post","photos":[],"_id":"cmes8p36e000alkw9gn309o1v","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>test uploading a pic in cnblogs</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145620944-648175100.png\" alt=\"image-20250714144612388\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145728019-230657612.png\" alt=\"image-20250714145658002\"></p>\n","excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>test uploading a pic in cnblogs</p>\n<p><img src=\"https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145620944-648175100.png\" alt=\"image-20250714144612388\"></p>\n<p><img src=\"https://img2024.cnblogs.com/blog/1928276/202507/1928276-20250714145728019-230657612.png\" alt=\"image-20250714145658002\"></p>\n"}],"PostAsset":[{"_id":"source/_posts/GAMES101-作业7-路径追踪-踩坑指南/image-20240416133728725.png","post":"cmes8p3660001lkw9b9z3912v","slug":"image-20240416133728725.png","modified":1,"renderable":0},{"_id":"source/_posts/GAMES101-作业7-路径追踪-踩坑指南/image-20240416133742442.png","post":"cmes8p3660001lkw9b9z3912v","slug":"image-20240416133742442.png","modified":1,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cmes8p36c0006lkw914m0fscw","tag_id":"cmes8p36a0004lkw966nq05y9","_id":"cmes8p36e0009lkw9c4wxcdct"},{"post_id":"cmes8p3660001lkw9b9z3912v","tag_id":"cmes8p36a0004lkw966nq05y9","_id":"cmes8p36f000blkw94475bllx"},{"post_id":"cmes8p3690003lkw96mz8cjzd","tag_id":"cmes8p36a0004lkw966nq05y9","_id":"cmes8p36f000clkw9ak1qcvts"}],"Tag":[{"name":"图形学","_id":"cmes8p36a0004lkw966nq05y9"}]}}